//--------------------------------------
// THIS FILE IS AUTOMATICALLY GENERATED
//             DO NOT EDIT
//   ALL CHANGES WILL BE OVERWRITTEN
//--------------------------------------

#ifndef _EL_PLUGIN_API_H_
#define _EL_PLUGIN_API_H_

# include <d3d9.h>
# include <d3dx9.h>
// This wrapper is used to stop errors from the old style modify to the new style...
#ifndef _EL_MODIFY_DLL_API_H_
# define _EL_MODIFY_DLL_API_H_
# if !defined(_EL_MODIFY_DLL_API_IGNORE_ALL_BAR_API_) && !defined(_TRANSFERSTRUCTS_H)

#define VAR_COUNT(x) ((WORD)(((x).var_data_count_h << 8) | (x).var_data_count_l))
#define SET_VAR_COUNT(dts, n) { (dts).var_data_count_h = (n) >> 8; (dts).var_data_count_l = (n) & 0xFF; }

typedef union { BYTE *byte_data; WORD *word_data; DWORD *dword_data; float *float_data; } DTS_pointer;

# define TS_CFGITEMHEADER_CONSTANT_INPUT 0xFFF0
# define ENGINELAB_MODIFY_DLL_VERSION 97


typedef struct tag_GenericArray_DTS
{
    BYTE var_data_size;
    BYTE var_data_count_h;
    BYTE var_data_count_l;
    DTS_pointer var;
}GenericArray_DTS, *pGenericArray_DTS;

//      PositionSensor_TS.edge_trigger
#define TS_POSITIONSENSOR_EDGE_TRIGGER_RISINGEDGE         0
#define TS_POSITIONSENSOR_EDGE_TRIGGER_FALLINGEDGE        1
#define TS_POSITIONSENSOR_EDGE_TRIGGER_RISINGFALLINGEDGES 2
#define TS_POSITIONSENSOR_EDGE_TRIGGER_COUNT_             3
typedef struct tag_PositionSensor_TS
{
    BYTE harness_pin_number;
    BYTE noise_cancellation;
    BYTE number_of_teeth;
    BYTE edge_trigger;
}PositionSensor_TS, *pPositionSensor_TS;

typedef struct tag_GenericStatusStringResponse_DTS {
    DWORD status;
    GenericArray_DTS str;
    BYTE var_data_size;
    BYTE var_data_count_h;
    BYTE var_data_count_l;
    DTS_pointer var;
}GenericStatusStringResponse_DTS, *pGenericStatusStringResponse_DTS;

#define TS_PERIPHERAL_HARNESSPINDESCRIPTORFORPLUGIN_PIN_NAME_LENGTH                     40
#define TS_PERIPHERAL_HARNESSPINDESCRIPTORFORPLUGIN_PIN_END                             0x00000000
#define TS_PERIPHERAL_HARNESSPINDESCRIPTORFORPLUGIN_HARNESS_PIN_STRING_LENGTH           8
//      Peripheral_HarnessPinDescriptorForPlugin_TS.Attributes
#define TS_PERIPHERAL_HARNESSPINDESCRIPTORFORPLUGIN_ATTRIBUTES_IS_RELAY_CONTROL_SHIFT   0
#define TS_PERIPHERAL_HARNESSPINDESCRIPTORFORPLUGIN_ATTRIBUTES_IS_RELAY_CONTROL_MASK    0x01
#define TS_PERIPHERAL_HARNESSPINDESCRIPTORFORPLUGIN_ATTRIBUTES_IS_RELAY_CONTROL__       0x01
#define TS_PERIPHERAL_HARNESSPINDESCRIPTORFORPLUGIN_ATTRIBUTES_IS_CRANK_CAM_INPUT_SHIFT 1
#define TS_PERIPHERAL_HARNESSPINDESCRIPTORFORPLUGIN_ATTRIBUTES_IS_CRANK_CAM_INPUT_MASK  0x02
#define TS_PERIPHERAL_HARNESSPINDESCRIPTORFORPLUGIN_ATTRIBUTES_IS_CRANK_CAM_INPUT__     0x02
#define TS_PERIPHERAL_HARNESSPINDESCRIPTORFORPLUGIN_ATTRIBUTES_IS_LOWSIDE_SHIFT         2
#define TS_PERIPHERAL_HARNESSPINDESCRIPTORFORPLUGIN_ATTRIBUTES_IS_LOWSIDE_MASK          0x04
#define TS_PERIPHERAL_HARNESSPINDESCRIPTORFORPLUGIN_ATTRIBUTES_IS_LOWSIDE__             0x04
#define TS_PERIPHERAL_HARNESSPINDESCRIPTORFORPLUGIN_ATTRIBUTES_IS_INJECTOR_SHIFT        3
#define TS_PERIPHERAL_HARNESSPINDESCRIPTORFORPLUGIN_ATTRIBUTES_IS_INJECTOR_MASK         0x08
#define TS_PERIPHERAL_HARNESSPINDESCRIPTORFORPLUGIN_ATTRIBUTES_IS_INJECTOR__            0x08
typedef struct tag_Peripheral_HarnessPinDescriptorForPlugin_TS {
    BYTE HarnessPinNumber;
    BYTE Attributes;
    BYTE PinName[TS_PERIPHERAL_HARNESSPINDESCRIPTORFORPLUGIN_PIN_NAME_LENGTH];
    BYTE harness_pin_string[TS_PERIPHERAL_HARNESSPINDESCRIPTORFORPLUGIN_HARNESS_PIN_STRING_LENGTH];
}Peripheral_HarnessPinDescriptorForPlugin_TS, *pPeripheral_HarnessPinDescriptorForPlugin_TS;

#define TS_CANSNIFFER_LAFM        0x3FFFFFFF
#define TS_CANSNIFFER_BUFFER_SIZE 0x2000
typedef struct tag_CANSniffer_TS {
    DWORD identifier;
    DWORD timestamp_h;
    DWORD timestamp_l;
    BYTE data_length;
    BYTE rsvd_0;
    BYTE rsvd_1;
    BYTE rsvd_2;
    BYTE msg_data[8];
}CANSniffer_TS, *pCANSniffer_TS;

//      ConfigurationItemHeader_modifiable_TS.mod_flags
#define TS_CFGITEMHEADER_MODIFIABLE_MOD_FLAGS_PRIVATE_ITEM_SHIFT     11
#define TS_CFGITEMHEADER_MODIFIABLE_MOD_FLAGS_PRIVATE_ITEM_MASK      0x0800
#define TS_CFGITEMHEADER_MODIFIABLE_MOD_FLAGS_PRIVATE_ITEM_ON        0x0800
#define TS_CFGITEMHEADER_MODIFIABLE_MOD_FLAGS_HIDDEN_SHIFT           0
#define TS_CFGITEMHEADER_MODIFIABLE_MOD_FLAGS_HIDDEN_MASK            0x0001
#define TS_CFGITEMHEADER_MODIFIABLE_MOD_FLAGS_HIDDEN_ON              0x0001
#define TS_CFGITEMHEADER_MODIFIABLE_MOD_FLAGS_CLAMP_OUTPUT_SHIFT     12
#define TS_CFGITEMHEADER_MODIFIABLE_MOD_FLAGS_CLAMP_OUTPUT_MASK      0x1000
#define TS_CFGITEMHEADER_MODIFIABLE_MOD_FLAGS_CLAMP_OUTPUT_ON        0x1000
#define TS_CFGITEMHEADER_MODIFIABLE_MOD_FLAGS_USE_TEST_OUTPUT_SHIFT  13
#define TS_CFGITEMHEADER_MODIFIABLE_MOD_FLAGS_USE_TEST_OUTPUT_MASK   0x2000
#define TS_CFGITEMHEADER_MODIFIABLE_MOD_FLAGS_USE_TEST_OUTPUT__      0x2000
#define TS_CFGITEMHEADER_MODIFIABLE_MOD_FLAGS_PASSWORD_PROTECT_SHIFT 14
#define TS_CFGITEMHEADER_MODIFIABLE_MOD_FLAGS_PASSWORD_PROTECT_MASK  0x4000
#define TS_CFGITEMHEADER_MODIFIABLE_MOD_FLAGS_PASSWORD_PROTECT__     0x4000
typedef struct tag_ConfigurationItemHeader_modifiable_TS {
    float outputValue;
    float outputValueInitial;
    float outputValueTest;
    float clamp_lower;
    float clamp_upper;
    BYTE type;
    WORD outputChannel;
    GenericArray_DTS channel_name;
    GenericArray_DTS input_channels;
    GenericArray_DTS input_data_pointers;
    WORD mod_flags;
}ConfigurationItemHeader_modifiable_TS, *pConfigurationItemHeader_modifiable_TS;

//      ConfigurationEngineDescriptorItem_modifiable_TS.cycles
#define TS_ENGINEDESCRIPTOR_ITEM_MODIFIABLE_CYCLES_TWOSTROKE                                              2
#define TS_ENGINEDESCRIPTOR_ITEM_MODIFIABLE_CYCLES_FOURSTROKE                                             4
//      ConfigurationEngineDescriptorItem_modifiable_TS.timing_type
#define TS_ENGINEDESCRIPTOR_ITEM_MODIFIABLE_TIMING_TYPE_SINGLETOOTHCAM                                    0
#define TS_ENGINEDESCRIPTOR_ITEM_MODIFIABLE_TIMING_TYPE_HONDA600RR                                        1
#define TS_ENGINEDESCRIPTOR_ITEM_MODIFIABLE_TIMING_TYPE_SINGLECAMCRANK1TOOTHMISSING                       2
#define TS_ENGINEDESCRIPTOR_ITEM_MODIFIABLE_TIMING_TYPE_SINGLECAMCRANK1TOOTHMISSING_VVT                   3
#define TS_ENGINEDESCRIPTOR_ITEM_MODIFIABLE_TIMING_TYPE_SINGLECAMCRANK2TOOTHMISSING                       4
#define TS_ENGINEDESCRIPTOR_ITEM_MODIFIABLE_TIMING_TYPE_SINGLECAMCRANK2TOOTHMISSING_VVT                   5
#define TS_ENGINEDESCRIPTOR_ITEM_MODIFIABLE_TIMING_TYPE_HONDACIVIC_5T_CAM_12_1CRANK                       6
#define TS_ENGINEDESCRIPTOR_ITEM_MODIFIABLE_TIMING_TYPE_HONDARSX_5T_4T_CAMS_12_1CRANK_VVT                 7
#define TS_ENGINEDESCRIPTOR_ITEM_MODIFIABLE_TIMING_TYPE_SUBARUWRXSTI_3T_3T_2T_2T_CAMS_36_2_2_2CRANK_VVT   8
#define TS_ENGINEDESCRIPTOR_ITEM_MODIFIABLE_TIMING_TYPE_1GDSM_2T_CAM_4_CRANK                              9
#define TS_ENGINEDESCRIPTOR_ITEM_MODIFIABLE_TIMING_TYPE_NISSAN_QG18DE_10T_CAM_36_2_CRANK                  10
#define TS_ENGINEDESCRIPTOR_ITEM_MODIFIABLE_TIMING_TYPE_DODGENGC_15T_CAM_36_2_2_CRANK_VVT                 11
#define TS_ENGINEDESCRIPTOR_ITEM_MODIFIABLE_TIMING_TYPE_DODGEVIPER92_95_4T_CAM_20_2_2_2_2_2_CRANK         12
#define TS_ENGINEDESCRIPTOR_ITEM_MODIFIABLE_TIMING_TYPE_DODGEVIPER96_1T_CAM_20_2_2_2_2_2_CRANK            13
#define TS_ENGINEDESCRIPTOR_ITEM_MODIFIABLE_TIMING_TYPE_MITSUBISHIEVO8_9_2T_CAM_4_CRANK_VVT               14
#define TS_ENGINEDESCRIPTOR_ITEM_MODIFIABLE_TIMING_TYPE_GM_LS7_4T_CAM_60_2_CRANK_VVT                      15
#define TS_ENGINEDESCRIPTOR_ITEM_MODIFIABLE_TIMING_TYPE_BMW_S54_7T_6T_CAMS_60_2_CRANK_VVT                 16
#define TS_ENGINEDESCRIPTOR_ITEM_MODIFIABLE_TIMING_TYPE_BMW_S65_7T_6T_CAMS_60_2_CRANK_VVT                 17
#define TS_ENGINEDESCRIPTOR_ITEM_MODIFIABLE_TIMING_TYPE_NISSAN_VQ35_6T_6T_CAMS_36_2_2_2_CRANK_VVT         18
#define TS_ENGINEDESCRIPTOR_ITEM_MODIFIABLE_TIMING_TYPE_NISSAN_VQ35_6T_6T_3T_3T_CAMS_36_2_2_2_CRANK_VVT   19
#define TS_ENGINEDESCRIPTOR_ITEM_MODIFIABLE_TIMING_TYPE_NISSAN_VQ37_6T_6T_CAMS_36_2_2_2_CRANK_VVT         20
#define TS_ENGINEDESCRIPTOR_ITEM_MODIFIABLE_TIMING_TYPE_TOYOTA_2JZGTE_3T_CAM_36_2_CRANK_VVT               21
#define TS_ENGINEDESCRIPTOR_ITEM_MODIFIABLE_TIMING_TYPE_DODGEVIPER4THGENERATION_5T_CAM_60_2_CRANK         22
#define TS_ENGINEDESCRIPTOR_ITEM_MODIFIABLE_TIMING_TYPE_HONDAJ35_37_3T_CAM_24_1_1_CRANK                   23
#define TS_ENGINEDESCRIPTOR_ITEM_MODIFIABLE_TIMING_TYPE_SUBARUEZ36_3T_3T_3T_3T_CAMS_36_2_2_2CRANK_VVT     24
#define TS_ENGINEDESCRIPTOR_ITEM_MODIFIABLE_TIMING_TYPE_HONDAF22C_3T_CAM_12_CRANK_VVT                     25
#define TS_ENGINEDESCRIPTOR_ITEM_MODIFIABLE_TIMING_TYPE_PORSCHE997_4T_4T_CAMS_60_2_CRANK_VVT              26
#define TS_ENGINEDESCRIPTOR_ITEM_MODIFIABLE_TIMING_TYPE_FORDCOYOTE_7T_7T_7T_7T_CAMS_36_1_CRANK_VVT        27
#define TS_ENGINEDESCRIPTOR_ITEM_MODIFIABLE_TIMING_TYPE_VOLKSWAGON_4T_CAMS_60_2_CRANK_VVT                 28
#define TS_ENGINEDESCRIPTOR_ITEM_MODIFIABLE_TIMING_TYPE_LAMBORGHINI_4T_4T_4T_4T_CAMS_36_1_1_1_1_CRANK_VVT 29
#define TS_ENGINEDESCRIPTOR_ITEM_MODIFIABLE_TIMING_TYPE_GM_LFX_4T_4T_4T_4T_CAMS_60_2_CRANK_VVT            30
#define TS_ENGINEDESCRIPTOR_ITEM_MODIFIABLE_TIMING_TYPE_TOYOTA_2GR_FE_3T_3T_3T_3T_CAMS_36_2_CRANK_VVT     31
#define TS_ENGINEDESCRIPTOR_ITEM_MODIFIABLE_TIMING_TYPE_YAMAHA_1800_1_CAM_4_1_CRANK                       32
#define TS_ENGINEDESCRIPTOR_ITEM_MODIFIABLE_TIMING_TYPE_NISSAN_RB26DETT_6_CAM_180_CRANK                   33
#define TS_ENGINEDESCRIPTOR_ITEM_MODIFIABLE_TIMING_TYPE_NISSAN_SR20DET_4_CAM_180_CRANK                    34
#define TS_ENGINEDESCRIPTOR_ITEM_MODIFIABLE_TIMING_TYPE_FORD_4_6_3V_5_5_CAM_36_1_CRANK                    35
#define TS_ENGINEDESCRIPTOR_ITEM_MODIFIABLE_TIMING_TYPE_MAZDA_L_MZR_6_CAM_36_2_2_2_CRANK_VVT              36
#define TS_ENGINEDESCRIPTOR_ITEM_MODIFIABLE_TIMING_TYPE_TOYOTA_3SGE_3T_3T_CAM_36_2_CRANK_VVT              37
#define TS_ENGINEDESCRIPTOR_ITEM_MODIFIABLE_TIMING_TYPE_CHRYSLER_6_4_HEMI_15T_CAM_60_2_CRANK_VVT          38
#define TS_ENGINEDESCRIPTOR_ITEM_MODIFIABLE_TIMING_TYPE_GM_ECOTEC_LE5_4T_4T_CAM_60_2_CRANK_VVT            39
#define TS_ENGINEDESCRIPTOR_ITEM_MODIFIABLE_TIMING_TYPE_COUNT_                                            40
//      ConfigurationEngineDescriptorItem_modifiable_TS.sync_response
#define TS_ENGINEDESCRIPTOR_ITEM_MODIFIABLE_SYNC_RESPONSE_STATE_NOT_SYNCED                                0
#define TS_ENGINEDESCRIPTOR_ITEM_MODIFIABLE_SYNC_RESPONSE_STATE_SYNCED                                    1
#define TS_ENGINEDESCRIPTOR_ITEM_MODIFIABLE_SYNC_RESPONSE_STATE_SYNC_ERROR_CRANK_TOOTH_MISSED             2
#define TS_ENGINEDESCRIPTOR_ITEM_MODIFIABLE_SYNC_RESPONSE_STATE_SYNC_ERROR_CRANK_TOOTH_PRESENT            3
#define TS_ENGINEDESCRIPTOR_ITEM_MODIFIABLE_SYNC_RESPONSE_STATE_SYNC_ERROR_PRIMARY_CAM_SIGNATURE          4
#define TS_ENGINEDESCRIPTOR_ITEM_MODIFIABLE_SYNC_RESPONSE_STATE_SYNC_ERROR_SECONDARY_CAM_SIGNATURE        5
#define TS_ENGINEDESCRIPTOR_ITEM_MODIFIABLE_SYNC_RESPONSE_STATE_SYNC_ERROR_SECONDARY0_CAM_SIGNATURE       6
#define TS_ENGINEDESCRIPTOR_ITEM_MODIFIABLE_SYNC_RESPONSE_STATE_SYNC_ERROR_SECONDARY1_CAM_SIGNATURE       7
#define TS_ENGINEDESCRIPTOR_ITEM_MODIFIABLE_SYNC_RESPONSE_STATE_SYNC_ERROR_SECONDARY2_CAM_SIGNATURE       8
#define TS_ENGINEDESCRIPTOR_ITEM_MODIFIABLE_SYNC_RESPONSE_STATE_SYNC_ERROR_SECONDARY3_CAM_SIGNATURE       9
#define TS_ENGINEDESCRIPTOR_ITEM_MODIFIABLE_SYNC_RESPONSE_STATE_SYNC_ERROR_SECONDARY4_CAM_SIGNATURE       10
#define TS_ENGINEDESCRIPTOR_ITEM_MODIFIABLE_SYNC_RESPONSE_STATE_SYNC_ERROR_SECONDARY5_CAM_SIGNATURE       11
#define TS_ENGINEDESCRIPTOR_ITEM_MODIFIABLE_SYNC_RESPONSE_STATE_SYNC_ERROR_SECONDARY6_CAM_SIGNATURE       12
#define TS_ENGINEDESCRIPTOR_ITEM_MODIFIABLE_SYNC_RESPONSE_STATE_SYNC_ERROR_SECONDARY7_CAM_SIGNATURE       13
#define TS_ENGINEDESCRIPTOR_ITEM_MODIFIABLE_SYNC_RESPONSE_STATE_SYNC_ERROR_SECONDARY8_CAM_SIGNATURE       14
#define TS_ENGINEDESCRIPTOR_ITEM_MODIFIABLE_SYNC_RESPONSE_STATE_SYNC_ERROR_SECONDARY9_CAM_SIGNATURE       15
#define TS_ENGINEDESCRIPTOR_ITEM_MODIFIABLE_SYNC_RESPONSE_STATE_SYNC_ERROR_SECONDARY10_CAM_SIGNATURE      16
#define TS_ENGINEDESCRIPTOR_ITEM_MODIFIABLE_SYNC_RESPONSE_STATE_SYNC_ERROR_SECONDARY11_CAM_SIGNATURE      17
#define TS_ENGINEDESCRIPTOR_ITEM_MODIFIABLE_SYNC_RESPONSE_STATE_SYNC_ERROR_SECONDARY12_CAM_SIGNATURE      18
#define TS_ENGINEDESCRIPTOR_ITEM_MODIFIABLE_SYNC_RESPONSE_STATE_SYNC_ERROR_SECONDARY13_CAM_SIGNATURE      19
#define TS_ENGINEDESCRIPTOR_ITEM_MODIFIABLE_SYNC_RESPONSE_STATE_SYNC_ERROR_SECONDARY14_CAM_SIGNATURE      20
#define TS_ENGINEDESCRIPTOR_ITEM_MODIFIABLE_SYNC_RESPONSE_STATE_SYNC_ERROR_SECONDARY15_CAM_SIGNATURE      21
#define TS_ENGINEDESCRIPTOR_ITEM_MODIFIABLE_SYNC_RESPONSE_STATE_SYNC_ERROR_GENERIC0                       22
#define TS_ENGINEDESCRIPTOR_ITEM_MODIFIABLE_SYNC_RESPONSE_STATE_SYNC_ERROR_GENERIC1                       23
#define TS_ENGINEDESCRIPTOR_ITEM_MODIFIABLE_SYNC_RESPONSE_STATE_SYNC_ERROR_GENERIC2                       24
#define TS_ENGINEDESCRIPTOR_ITEM_MODIFIABLE_SYNC_RESPONSE_STATE_SYNC_ERROR_GENERIC3                       25
#define TS_ENGINEDESCRIPTOR_ITEM_MODIFIABLE_SYNC_RESPONSE_STATE_SYNC_ERROR_GENERIC4                       26
#define TS_ENGINEDESCRIPTOR_ITEM_MODIFIABLE_SYNC_RESPONSE_STATE_SYNC_ERROR_GENERIC5                       27
#define TS_ENGINEDESCRIPTOR_ITEM_MODIFIABLE_SYNC_RESPONSE_STATE_SYNC_ERROR_GENERIC6                       28
#define TS_ENGINEDESCRIPTOR_ITEM_MODIFIABLE_SYNC_RESPONSE_STATE_SYNC_ERROR_GENERIC7                       29
#define TS_ENGINEDESCRIPTOR_ITEM_MODIFIABLE_SYNC_RESPONSE_STATE_SYNC_ERROR_GENERIC8                       30
#define TS_ENGINEDESCRIPTOR_ITEM_MODIFIABLE_SYNC_RESPONSE_STATE_SYNC_ERROR_GENERIC9                       31
#define TS_ENGINEDESCRIPTOR_ITEM_MODIFIABLE_SYNC_RESPONSE_COUNT_                                          32
//      ConfigurationEngineDescriptorItem_modifiable_TS.coil_type
#define TS_ENGINEDESCRIPTOR_ITEM_MODIFIABLE_COIL_TYPE_SETUP_SHIFT                                         0
#define TS_ENGINEDESCRIPTOR_ITEM_MODIFIABLE_COIL_TYPE_SETUP_MASK                                          0x03
#define TS_ENGINEDESCRIPTOR_ITEM_MODIFIABLE_COIL_TYPE_SETUP_COP                                           0x00
#define TS_ENGINEDESCRIPTOR_ITEM_MODIFIABLE_COIL_TYPE_SETUP_WASTED_SPARK                                  0x01
#define TS_ENGINEDESCRIPTOR_ITEM_MODIFIABLE_COIL_TYPE_SETUP_DISTRIBUTOR                                   0x02
#define TS_ENGINEDESCRIPTOR_ITEM_MODIFIABLE_COIL_TYPE_INVERT_SHIFT                                        2
#define TS_ENGINEDESCRIPTOR_ITEM_MODIFIABLE_COIL_TYPE_INVERT_MASK                                         0x04
#define TS_ENGINEDESCRIPTOR_ITEM_MODIFIABLE_COIL_TYPE_INVERT__                                            0x04
typedef struct tag_ConfigurationEngineDescriptorItem_modifiable_TS {
    ConfigurationItemHeader_modifiable_TS header;
    PositionSensor_TS crank;
    PositionSensor_TS cam0;
    PositionSensor_TS cam1;
    PositionSensor_TS cam2;
    PositionSensor_TS cam3;
    BYTE noise_cancellation_mode;
    BYTE num_coils;
    BYTE num_sparks;
    BYTE num_injectors;
    BYTE coil_type;
    BYTE num_cylinders;
    BYTE cycles;
    BYTE timing_type;
    float displacement;
    GenericArray_DTS spark_base_timings;
    GenericArray_DTS injector_base_timings;
    GenericArray_DTS spark_knock_sense_indexes;
    GenericArray_DTS spark_knock_sense_timings;
    GenericArray_DTS spark_knock_sense_widths;
    GenericArray_DTS sync_response;
    GenericArray_DTS misc_settings;
    BYTE crank_speed_sparking_toothoffset;
    BYTE crank_speed_sparking_toothcount;
    BYTE gdi_pump_cam_number;
    BYTE gdi_pump_cam_number_of_lobes;
}ConfigurationEngineDescriptorItem_modifiable_TS, *pConfigurationEngineDescriptorItem_modifiable_TS;

typedef struct tag_ConfigurationPassthroughItem_modifiable_TS {
    ConfigurationItemHeader_modifiable_TS header;
}ConfigurationPassthroughItem_modifiable_TS, *pConfigurationPassthroughItem_modifiable_TS;

typedef struct tag_ConfigurationAnalogInputConditioningItem_modifiable_TS {
    ConfigurationItemHeader_modifiable_TS header;
    float input_min;
    float input_max;
    float clamping_override;
    BYTE clamping_override_enable;
}ConfigurationAnalogInputConditioningItem_modifiable_TS, *pConfigurationAnalogInputConditioningItem_modifiable_TS;

typedef struct tag_ConfigurationPredefItem_modifiable_TS {
    ConfigurationItemHeader_modifiable_TS header;
}ConfigurationPredefItem_modifiable_TS, *pConfigurationPredefItem_modifiable_TS;

typedef struct tag_ConfigurationMathItem_modifiable_TS {
    ConfigurationItemHeader_modifiable_TS header;
}ConfigurationMathItem_modifiable_TS, *pConfigurationMathItem_modifiable_TS;

typedef struct tag_ConfigurationIfElseItem_modifiable_TS {
    ConfigurationItemHeader_modifiable_TS header;
}ConfigurationIfElseItem_modifiable_TS, *pConfigurationIfElseItem_modifiable_TS;

//      Configuration1DTableItem_modifiable_DTS.cell_adjust
#define TS_1DTABLE_ITEM_MODIFIABLE_CELL_ADJUST_DISABLED     0
#define TS_1DTABLE_ITEM_MODIFIABLE_CELL_ADJUST_ASSIGN       1
#define TS_1DTABLE_ITEM_MODIFIABLE_CELL_ADJUST_ADD          2
#define TS_1DTABLE_ITEM_MODIFIABLE_CELL_ADJUST_MULTIPLY     3
#define TS_1DTABLE_ITEM_MODIFIABLE_CELL_ADJUST_FILTER_50    10
#define TS_1DTABLE_ITEM_MODIFIABLE_CELL_ADJUST_FILTER_60    20
#define TS_1DTABLE_ITEM_MODIFIABLE_CELL_ADJUST_FILTER_70    30
#define TS_1DTABLE_ITEM_MODIFIABLE_CELL_ADJUST_FILTER_80    40
#define TS_1DTABLE_ITEM_MODIFIABLE_CELL_ADJUST_FILTER_90    50
#define TS_1DTABLE_ITEM_MODIFIABLE_CELL_ADJUST_FILTER_91    60
#define TS_1DTABLE_ITEM_MODIFIABLE_CELL_ADJUST_FILTER_92    70
#define TS_1DTABLE_ITEM_MODIFIABLE_CELL_ADJUST_FILTER_93    80
#define TS_1DTABLE_ITEM_MODIFIABLE_CELL_ADJUST_FILTER_94    90
#define TS_1DTABLE_ITEM_MODIFIABLE_CELL_ADJUST_FILTER_95    100
#define TS_1DTABLE_ITEM_MODIFIABLE_CELL_ADJUST_FILTER_96    120
#define TS_1DTABLE_ITEM_MODIFIABLE_CELL_ADJUST_FILTER_97    140
#define TS_1DTABLE_ITEM_MODIFIABLE_CELL_ADJUST_FILTER_98    160
#define TS_1DTABLE_ITEM_MODIFIABLE_CELL_ADJUST_FILTER_99    180
#define TS_1DTABLE_ITEM_MODIFIABLE_CELL_ADJUST_FILTER_100   200
typedef struct tag_Configuration1DTableItem_modifiable_DTS {
    ConfigurationItemHeader_modifiable_TS header;
    GenericArray_DTS axis_points;
    float range_min;
    float range_max;
    BYTE interpolate;
    BYTE axis_selector;
    BYTE cell_adjust;
    BYTE var_data_size;
    BYTE var_data_count_h;
    BYTE var_data_count_l;
    DTS_pointer var;
}Configuration1DTableItem_modifiable_DTS, *pConfiguration1DTableItem_modifiable_DTS;

//      Configuration2DTableItem_modifiable_DTS.cell_adjust
#define TS_2DTABLE_ITEM_MODIFIABLE_CELL_ADJUST_DISABLED     0
#define TS_2DTABLE_ITEM_MODIFIABLE_CELL_ADJUST_ASSIGN       1
#define TS_2DTABLE_ITEM_MODIFIABLE_CELL_ADJUST_ADD          2
#define TS_2DTABLE_ITEM_MODIFIABLE_CELL_ADJUST_MULTIPLY     3
#define TS_2DTABLE_ITEM_MODIFIABLE_CELL_ADJUST_FILTER_50    10
#define TS_2DTABLE_ITEM_MODIFIABLE_CELL_ADJUST_FILTER_60    20
#define TS_2DTABLE_ITEM_MODIFIABLE_CELL_ADJUST_FILTER_70    30
#define TS_2DTABLE_ITEM_MODIFIABLE_CELL_ADJUST_FILTER_80    40
#define TS_2DTABLE_ITEM_MODIFIABLE_CELL_ADJUST_FILTER_90    50
#define TS_2DTABLE_ITEM_MODIFIABLE_CELL_ADJUST_FILTER_91    60
#define TS_2DTABLE_ITEM_MODIFIABLE_CELL_ADJUST_FILTER_92    70
#define TS_2DTABLE_ITEM_MODIFIABLE_CELL_ADJUST_FILTER_93    80
#define TS_2DTABLE_ITEM_MODIFIABLE_CELL_ADJUST_FILTER_94    90
#define TS_2DTABLE_ITEM_MODIFIABLE_CELL_ADJUST_FILTER_95    100
#define TS_2DTABLE_ITEM_MODIFIABLE_CELL_ADJUST_FILTER_96    120
#define TS_2DTABLE_ITEM_MODIFIABLE_CELL_ADJUST_FILTER_97    140
#define TS_2DTABLE_ITEM_MODIFIABLE_CELL_ADJUST_FILTER_98    160
#define TS_2DTABLE_ITEM_MODIFIABLE_CELL_ADJUST_FILTER_99    180
#define TS_2DTABLE_ITEM_MODIFIABLE_CELL_ADJUST_FILTER_100   200
typedef struct tag_Configuration2DTableItem_modifiable_DTS {
    ConfigurationItemHeader_modifiable_TS header;
    GenericArray_DTS axis0_points;
    GenericArray_DTS axis1_points;
    float range_min;
    float range_max;
    BYTE interpolate;
    BYTE axis0_selector;
    BYTE axis1_selector;
    BYTE cell_adjust;
    BYTE var_data_size;
    BYTE var_data_count_h;
    BYTE var_data_count_l;
    DTS_pointer var;
}Configuration2DTableItem_modifiable_DTS, *pConfiguration2DTableItem_modifiable_DTS;

typedef struct tag_ConfigurationRunningAverageItem_modifiable_TS {
    ConfigurationItemHeader_modifiable_TS header;
}ConfigurationRunningAverageItem_modifiable_TS, *pConfigurationRunningAverageItem_modifiable_TS;

typedef struct tag_ConfigurationSlopeItem_modifiable_TS {
    ConfigurationItemHeader_modifiable_TS header;
}ConfigurationSlopeItem_modifiable_TS, *pConfigurationSlopeItem_modifiable_TS;

typedef struct tag_ConfigurationMultiplexItem_modifiable_TS {
    ConfigurationItemHeader_modifiable_TS header;
}ConfigurationMultiplexItem_modifiable_TS, *pConfigurationMultiplexItem_modifiable_TS;

typedef struct tag_ConfigurationMafFuelRequirementItem_modifiable_TS {
    ConfigurationItemHeader_modifiable_TS header;
}ConfigurationMafFuelRequirementItem_modifiable_TS, *pConfigurationMafFuelRequirementItem_modifiable_TS;

typedef struct tag_ConfigurationLimitingItem_modifiable_TS {
    ConfigurationItemHeader_modifiable_TS header;
}ConfigurationLimitingItem_modifiable_TS, *pConfigurationLimitingItem_modifiable_TS;

typedef struct tag_ConfigurationProfilerItem_modifiable_TS {
    ConfigurationItemHeader_modifiable_TS header;
}ConfigurationProfilerItem_modifiable_TS, *pConfigurationProfilerItem_modifiable_TS;

typedef struct tag_ConfigurationEmbeddedCodeItem_modifiable_TS {
    ConfigurationItemHeader_modifiable_TS header;
    GenericArray_DTS storage;
    GenericArray_DTS locals;
}ConfigurationEmbeddedCodeItem_modifiable_TS, *pConfigurationEmbeddedCodeItem_modifiable_TS;

typedef struct tag_ConfigurationUnitConversionItem_modifiable_TS {
    ConfigurationItemHeader_modifiable_TS header;
}ConfigurationUnitConversionItem_modifiable_TS, *pConfigurationUnitConversionItem_modifiable_TS;

//      ConfigurationThermistorItem_modifiable_TS._output_type
#define TS_THERMISTOR_ITEM_MODIFIABLE__OUTPUT_TYPE_RESISTANCEOHMS            0
#define TS_THERMISTOR_ITEM_MODIFIABLE__OUTPUT_TYPE_COOLANTTEMPDEGC           1
#define TS_THERMISTOR_ITEM_MODIFIABLE__OUTPUT_TYPE_AIRTEMPDEGC               2
#define TS_THERMISTOR_ITEM_MODIFIABLE__OUTPUT_TYPE_CLT_1GDSM_DEGC            3
#define TS_THERMISTOR_ITEM_MODIFIABLE__OUTPUT_TYPE_CLT_GM12146312_DEGC       4
#define TS_THERMISTOR_ITEM_MODIFIABLE__OUTPUT_TYPE_CLT_SUPRA_19937_DEGC      5
#define TS_THERMISTOR_ITEM_MODIFIABLE__OUTPUT_TYPE_CLT_HONDA1990_01_DEGC     6
#define TS_THERMISTOR_ITEM_MODIFIABLE__OUTPUT_TYPE_CLT_HONDA2002_06_DEGC     7
#define TS_THERMISTOR_ITEM_MODIFIABLE__OUTPUT_TYPE_CLT_SUBARU2004_06_DEGC    8
#define TS_THERMISTOR_ITEM_MODIFIABLE__OUTPUT_TYPE_CLT_EVO89_2GDSM_DEGC      9
#define TS_THERMISTOR_ITEM_MODIFIABLE__OUTPUT_TYPE_CLT_ACURACLT_DEGC         10
#define TS_THERMISTOR_ITEM_MODIFIABLE__OUTPUT_TYPE_AIR_GM25036751_DEGC       11
#define TS_THERMISTOR_ITEM_MODIFIABLE__OUTPUT_TYPE_AIR_HONDAS2000_00_05_DEGC 12
#define TS_THERMISTOR_ITEM_MODIFIABLE__OUTPUT_TYPE_AIR_HONDA1990_01_DEGC     13
#define TS_THERMISTOR_ITEM_MODIFIABLE__OUTPUT_TYPE_AIR_SUBARUSTI2004_06_DEGC 14
#define TS_THERMISTOR_ITEM_MODIFIABLE__OUTPUT_TYPE_AIR_TOYOTAMAF_DEGC        15
#define TS_THERMISTOR_ITEM_MODIFIABLE__OUTPUT_TYPE_AIR_NISSAN_DEGC           16
#define TS_THERMISTOR_ITEM_MODIFIABLE__OUTPUT_TYPE_COUNT_                    17
typedef struct tag_ConfigurationThermistorItem_modifiable_TS {
    ConfigurationItemHeader_modifiable_TS header;
    BYTE _output_type;
}ConfigurationThermistorItem_modifiable_TS, *pConfigurationThermistorItem_modifiable_TS;

typedef struct tag_ConfigurationPIDItem_modifiable_TS {
    ConfigurationItemHeader_modifiable_TS header;
}ConfigurationPIDItem_modifiable_TS, *pConfigurationPIDItem_modifiable_TS;

typedef struct tag_ConfigurationObdiiPIDItem_modifiable_TS {
    ConfigurationItemHeader_modifiable_TS header;
}ConfigurationObdiiPIDItem_modifiable_TS, *pConfigurationObdiiPIDItem_modifiable_TS;

typedef struct tag_ConfigurationObdiiTIDItem_modifiable_TS {
    ConfigurationItemHeader_modifiable_TS header;
}ConfigurationObdiiTIDItem_modifiable_TS, *pConfigurationObdiiTIDItem_modifiable_TS;

typedef struct tag_ConfigurationSpeedDensityItem_modifiable_TS {
    ConfigurationItemHeader_modifiable_TS header;
}ConfigurationSpeedDensityItem_modifiable_TS, *pConfigurationSpeedDensityItem_modifiable_TS;

typedef struct tag_ConfigurationTimerItem_modifiable_TS {
    ConfigurationItemHeader_modifiable_TS header;
}ConfigurationTimerItem_modifiable_TS, *pConfigurationTimerItem_modifiable_TS;

//      ConfigurationHardwareIOItem_modifiable_TS.harness_pin_mode
#define TS_HARDWAREIO_ITEM_MODIFIABLE_HARNESS_PIN_MODE_PULLUP_4700_OHM          0
#define TS_HARDWAREIO_ITEM_MODIFIABLE_HARNESS_PIN_MODE_PULLUP_10000_OHM         1
#define TS_HARDWAREIO_ITEM_MODIFIABLE_HARNESS_PIN_MODE_PULLUP_2200_OHM          2
#define TS_HARDWAREIO_ITEM_MODIFIABLE_HARNESS_PIN_MODE_LOWSIDE_2_AMP            3
#define TS_HARDWAREIO_ITEM_MODIFIABLE_HARNESS_PIN_MODE_LOWSIDE_5_AMP            4
#define TS_HARDWAREIO_ITEM_MODIFIABLE_HARNESS_PIN_MODE_LOWSIDE_10_AMP           5
#define TS_HARDWAREIO_ITEM_MODIFIABLE_HARNESS_PIN_MODE_HIGHSIDE_2_AMP           6
#define TS_HARDWAREIO_ITEM_MODIFIABLE_HARNESS_PIN_MODE_HIGHSIDE_5_AMP           7
#define TS_HARDWAREIO_ITEM_MODIFIABLE_HARNESS_PIN_MODE_HIGHSIDE_10_AMP          8
#define TS_HARDWAREIO_ITEM_MODIFIABLE_HARNESS_PIN_MODE_VARIABLE_RELUCTANCE      9
#define TS_HARDWAREIO_ITEM_MODIFIABLE_HARNESS_PIN_MODE_OPEN_COLLECTOR_200_MAMP  10
#define TS_HARDWAREIO_ITEM_MODIFIABLE_HARNESS_PIN_MODE_OPEN_COLLECTOR_4_AMP     11
#define TS_HARDWAREIO_ITEM_MODIFIABLE_HARNESS_PIN_MODE_NO_DRIVE_DIRECT_CONNECT  12
#define TS_HARDWAREIO_ITEM_MODIFIABLE_HARNESS_PIN_MODE_LOWSIDE_2_8_AMP          13
#define TS_HARDWAREIO_ITEM_MODIFIABLE_HARNESS_PIN_MODE_LOWSIDE_2_8_WPULLUP      14
#define TS_HARDWAREIO_ITEM_MODIFIABLE_HARNESS_PIN_MODE_LOWSIDE_6_AMP            15
#define TS_HARDWAREIO_ITEM_MODIFIABLE_HARNESS_PIN_MODE_LOWSIDE_6_WPULLUP        16
#define TS_HARDWAREIO_ITEM_MODIFIABLE_HARNESS_PIN_MODE_LOWSIDE_18_AMP           17
#define TS_HARDWAREIO_ITEM_MODIFIABLE_HARNESS_PIN_MODE_LOWSIDE_18_WPULLUP       18
#define TS_HARDWAREIO_ITEM_MODIFIABLE_HARNESS_PIN_MODE_INPUT_TRANSISTOR_SWITCH  19
#define TS_HARDWAREIO_ITEM_MODIFIABLE_HARNESS_PIN_MODE_INPUT_TRANSISTOR_WPULLUP 20
#define TS_HARDWAREIO_ITEM_MODIFIABLE_HARNESS_PIN_MODE_OPTOCOUPLER              21
#define TS_HARDWAREIO_ITEM_MODIFIABLE_HARNESS_PIN_MODE_STEPPERMOTORCONTROLLER   22
#define TS_HARDWAREIO_ITEM_MODIFIABLE_HARNESS_PIN_MODE_LOWSIDE_2_8_WFLYBACK     23
#define TS_HARDWAREIO_ITEM_MODIFIABLE_HARNESS_PIN_MODE_LOWSIDE_6_WFLYBACK       24
#define TS_HARDWAREIO_ITEM_MODIFIABLE_HARNESS_PIN_MODE_LOWSIDE_18_WFLYBACK      25
#define TS_HARDWAREIO_ITEM_MODIFIABLE_HARNESS_PIN_MODE_RS232_RX                 26
#define TS_HARDWAREIO_ITEM_MODIFIABLE_HARNESS_PIN_MODE_RS232_TX                 27
#define TS_HARDWAREIO_ITEM_MODIFIABLE_HARNESS_PIN_MODE_DAC128S085               28
#define TS_HARDWAREIO_ITEM_MODIFIABLE_HARNESS_PIN_MODE_COUNT_                   29
typedef struct tag_ConfigurationHardwareIOItem_modifiable_TS {
    ConfigurationItemHeader_modifiable_TS header;
    BYTE harness_pin_mode;
}ConfigurationHardwareIOItem_modifiable_TS, *pConfigurationHardwareIOItem_modifiable_TS;

//      ConfigurationFixed1DTableItem_modifiable_TS._table_type
#define TS_FIXED1DTABLE_ITEM_MODIFIABLE__TABLE_TYPE_MASSAIRFLOWSENSORLS1 0
#define TS_FIXED1DTABLE_ITEM_MODIFIABLE__TABLE_TYPE_MASSAIRFLOWSENSORLS6 1
#define TS_FIXED1DTABLE_ITEM_MODIFIABLE__TABLE_TYPE_COUNT_               2
typedef struct tag_ConfigurationFixed1DTableItem_modifiable_TS {
    ConfigurationItemHeader_modifiable_TS header;
    WORD _table_type;
}ConfigurationFixed1DTableItem_modifiable_TS, *pConfigurationFixed1DTableItem_modifiable_TS;

typedef struct tag_ConfigurationPlantHardwareWriterItem_modifiable_TS {
    ConfigurationItemHeader_modifiable_TS header;
}ConfigurationPlantHardwareWriterItem_modifiable_TS, *pConfigurationPlantHardwareWriterItem_modifiable_TS;

typedef struct tag_ConfigurationDiagnosticCodeItem_modifiable_TS {
    ConfigurationItemHeader_modifiable_TS header;
}ConfigurationDiagnosticCodeItem_modifiable_TS, *pConfigurationDiagnosticCodeItem_modifiable_TS;

typedef struct tag_ConfigurationLatchItem_modifiable_TS {
    ConfigurationItemHeader_modifiable_TS header;
}ConfigurationLatchItem_modifiable_TS, *pConfigurationLatchItem_modifiable_TS;

typedef struct tag_ConfigurationLambdaStagedItem_modifiable_TS {
    ConfigurationItemHeader_modifiable_TS header;
    float primary_fuel_stoich_af;
    float primary_fuel_density;
    float secondary_fuel_stoich_af;
    float secondary_fuel_density;
    BYTE number_of_primary_injectors;
    BYTE number_of_secondary_injectors;
    GenericArray_DTS primary_injector_numbers;
    GenericArray_DTS secondary_injector_numbers;
}ConfigurationLambdaStagedItem_modifiable_TS, *pConfigurationLambdaStagedItem_modifiable_TS;

typedef struct tag_ConfigurationPrivateItem_modifiable_TS {
    ConfigurationItemHeader_modifiable_TS header;
}ConfigurationPrivateItem_modifiable_TS, *pConfigurationPrivateItem_modifiable_TS;

typedef struct tag_ConfigurationCAN_SimpleTransmitItem_modifiable_TS {
    ConfigurationItemHeader_modifiable_TS header;
    BYTE CAN_channel;
    DWORD CAN_id;
    GenericArray_DTS data_buffer;
}ConfigurationCAN_SimpleTransmitItem_modifiable_TS, *pConfigurationCAN_SimpleTransmitItem_modifiable_TS;

//      ConfigurationCJ125Item_modifiable_TS.read_latch
#define TS_CJ125_ITEM_MODIFIABLE_READ_LATCH_EDGE_SHIFT            0
#define TS_CJ125_ITEM_MODIFIABLE_READ_LATCH_EDGE_MASK             0x03
#define TS_CJ125_ITEM_MODIFIABLE_READ_LATCH_EDGE_RISING_EDGE      0x01
#define TS_CJ125_ITEM_MODIFIABLE_READ_LATCH_EDGE_FALLING_EDGE     0x02
#define TS_CJ125_ITEM_MODIFIABLE_READ_LATCH_START_STATE_SHIFT     4
#define TS_CJ125_ITEM_MODIFIABLE_READ_LATCH_START_STATE_MASK      0x30
#define TS_CJ125_ITEM_MODIFIABLE_READ_LATCH_START_STATE_ZERO      0x00
#define TS_CJ125_ITEM_MODIFIABLE_READ_LATCH_START_STATE_NON_ZERO  0x10
#define TS_CJ125_ITEM_MODIFIABLE_READ_LATCH_START_STATE_COUNT_    2
//      ConfigurationCJ125Item_modifiable_TS.write_latch
#define TS_CJ125_ITEM_MODIFIABLE_WRITE_LATCH_EDGE_SHIFT           0
#define TS_CJ125_ITEM_MODIFIABLE_WRITE_LATCH_EDGE_MASK            0x03
#define TS_CJ125_ITEM_MODIFIABLE_WRITE_LATCH_EDGE_RISING_EDGE     0x01
#define TS_CJ125_ITEM_MODIFIABLE_WRITE_LATCH_EDGE_FALLING_EDGE    0x02
#define TS_CJ125_ITEM_MODIFIABLE_WRITE_LATCH_START_STATE_SHIFT    4
#define TS_CJ125_ITEM_MODIFIABLE_WRITE_LATCH_START_STATE_MASK     0x30
#define TS_CJ125_ITEM_MODIFIABLE_WRITE_LATCH_START_STATE_ZERO     0x00
#define TS_CJ125_ITEM_MODIFIABLE_WRITE_LATCH_START_STATE_NON_ZERO 0x10
#define TS_CJ125_ITEM_MODIFIABLE_WRITE_LATCH_START_STATE_COUNT_   2
typedef struct tag_ConfigurationCJ125Item_modifiable_TS {
    ConfigurationItemHeader_modifiable_TS header;
    BYTE read_latch;
    BYTE write_latch;
}ConfigurationCJ125Item_modifiable_TS, *pConfigurationCJ125Item_modifiable_TS;

//      ConfigurationEALEventItem_modifiable_TS.event_latch
#define TS_EALEVENT_ITEM_MODIFIABLE_EVENT_LATCH_EDGE_SHIFT                      0
#define TS_EALEVENT_ITEM_MODIFIABLE_EVENT_LATCH_EDGE_MASK                       0x03
#define TS_EALEVENT_ITEM_MODIFIABLE_EVENT_LATCH_EDGE_RISING_EDGE                0x01
#define TS_EALEVENT_ITEM_MODIFIABLE_EVENT_LATCH_EDGE_FALLING_EDGE               0x02
#define TS_EALEVENT_ITEM_MODIFIABLE_EVENT_LATCH_START_STATE_SHIFT               4
#define TS_EALEVENT_ITEM_MODIFIABLE_EVENT_LATCH_START_STATE_MASK                0x30
#define TS_EALEVENT_ITEM_MODIFIABLE_EVENT_LATCH_START_STATE_ZERO                0x00
#define TS_EALEVENT_ITEM_MODIFIABLE_EVENT_LATCH_START_STATE_NON_ZERO            0x10
#define TS_EALEVENT_ITEM_MODIFIABLE_EVENT_LATCH_START_STATE_COUNT_              2
#define TS_EALEVENT_ITEM_MODIFIABLE_EVENT_LATCH_INITIALIZED_SHIFT               6
#define TS_EALEVENT_ITEM_MODIFIABLE_EVENT_LATCH_INITIALIZED_MASK                0x40
#define TS_EALEVENT_ITEM_MODIFIABLE_EVENT_LATCH_INITIALIZED__                   0x40
//      ConfigurationEALEventItem_modifiable_TS.event_type
#define TS_EALEVENT_ITEM_MODIFIABLE_EVENT_TYPE_INJECTOR_EVENT_SHIFT             0
#define TS_EALEVENT_ITEM_MODIFIABLE_EVENT_TYPE_INJECTOR_EVENT_MASK              0x01
#define TS_EALEVENT_ITEM_MODIFIABLE_EVENT_TYPE_INJECTOR_EVENT__                 0x01
#define TS_EALEVENT_ITEM_MODIFIABLE_EVENT_TYPE_SPARK_EVENT_SHIFT                1
#define TS_EALEVENT_ITEM_MODIFIABLE_EVENT_TYPE_SPARK_EVENT_MASK                 0x02
#define TS_EALEVENT_ITEM_MODIFIABLE_EVENT_TYPE_SPARK_EVENT__                    0x02
#define TS_EALEVENT_ITEM_MODIFIABLE_EVENT_TYPE_SAVE_DATA_AND_COMMIT_EVENT_SHIFT 2
#define TS_EALEVENT_ITEM_MODIFIABLE_EVENT_TYPE_SAVE_DATA_AND_COMMIT_EVENT_MASK  0x04
#define TS_EALEVENT_ITEM_MODIFIABLE_EVENT_TYPE_SAVE_DATA_AND_COMMIT_EVENT__     0x04
typedef struct tag_ConfigurationEALEventItem_modifiable_TS {
    ConfigurationItemHeader_modifiable_TS header;
    BYTE event_latch;
    BYTE event_type;
    BYTE event_index;
    GenericArray_DTS save_data;
}ConfigurationEALEventItem_modifiable_TS, *pConfigurationEALEventItem_modifiable_TS;

//      ConfigurationHIP9011Item_modifiable_TS.write_latch
#define TS_HIP9011_ITEM_MODIFIABLE_WRITE_LATCH_EDGE_SHIFT           0
#define TS_HIP9011_ITEM_MODIFIABLE_WRITE_LATCH_EDGE_MASK            0x03
#define TS_HIP9011_ITEM_MODIFIABLE_WRITE_LATCH_EDGE_RISING_EDGE     0x01
#define TS_HIP9011_ITEM_MODIFIABLE_WRITE_LATCH_EDGE_FALLING_EDGE    0x02
#define TS_HIP9011_ITEM_MODIFIABLE_WRITE_LATCH_START_STATE_SHIFT    4
#define TS_HIP9011_ITEM_MODIFIABLE_WRITE_LATCH_START_STATE_MASK     0x30
#define TS_HIP9011_ITEM_MODIFIABLE_WRITE_LATCH_START_STATE_ZERO     0x00
#define TS_HIP9011_ITEM_MODIFIABLE_WRITE_LATCH_START_STATE_NON_ZERO 0x10
#define TS_HIP9011_ITEM_MODIFIABLE_WRITE_LATCH_START_STATE_COUNT_   2
typedef struct tag_ConfigurationHIP9011Item_modifiable_TS {
    ConfigurationItemHeader_modifiable_TS header;
    BYTE write_latch;
    BYTE bandpassfilterfrequency;
    BYTE gaincontrol;
    BYTE integratortimeconstant;
    BYTE test;
    BYTE prescalar;
}ConfigurationHIP9011Item_modifiable_TS, *pConfigurationHIP9011Item_modifiable_TS;

typedef struct tag_ConfigurationPlaybackItem_modifiable_TS {
    ConfigurationItemHeader_modifiable_TS header;
}ConfigurationPlaybackItem_modifiable_TS, *pConfigurationPlaybackItem_modifiable_TS;

//      ConfigurationCommunicationSimpleItem_modifiable_TS.data_type
#define TS_COMMUNICATIONSIMPLE_ITEM_MODIFIABLE_DATA_TYPE_FLOAT_2_INT8                                      0
#define TS_COMMUNICATIONSIMPLE_ITEM_MODIFIABLE_DATA_TYPE_FLOAT_2_INT16                                     1
#define TS_COMMUNICATIONSIMPLE_ITEM_MODIFIABLE_DATA_TYPE_FLOAT_2_INT32                                     2
#define TS_COMMUNICATIONSIMPLE_ITEM_MODIFIABLE_DATA_TYPE_FLOAT_2_FLOAT                                     3
#define TS_COMMUNICATIONSIMPLE_ITEM_MODIFIABLE_DATA_TYPE_UINT32_2_INT8                                     4
#define TS_COMMUNICATIONSIMPLE_ITEM_MODIFIABLE_DATA_TYPE_UINT32_2_INT16                                    5
#define TS_COMMUNICATIONSIMPLE_ITEM_MODIFIABLE_DATA_TYPE_UINT32_2_INT32                                    6
#define TS_COMMUNICATIONSIMPLE_ITEM_MODIFIABLE_DATA_TYPE_UINT32_2_FLOAT                                    7
#define TS_COMMUNICATIONSIMPLE_ITEM_MODIFIABLE_DATA_TYPE_INT32_2_INT8                                      8
#define TS_COMMUNICATIONSIMPLE_ITEM_MODIFIABLE_DATA_TYPE_INT32_2_INT16                                     9
#define TS_COMMUNICATIONSIMPLE_ITEM_MODIFIABLE_DATA_TYPE_INT32_2_INT32                                     10
#define TS_COMMUNICATIONSIMPLE_ITEM_MODIFIABLE_DATA_TYPE_INT32_2_FLOAT                                     11
#define TS_COMMUNICATIONSIMPLE_ITEM_MODIFIABLE_DATA_TYPE_UINT16_2_INT32                                    12
#define TS_COMMUNICATIONSIMPLE_ITEM_MODIFIABLE_DATA_TYPE_UINT16_2_FLOAT                                    13
#define TS_COMMUNICATIONSIMPLE_ITEM_MODIFIABLE_DATA_TYPE_INT16_2_INT32                                     14
#define TS_COMMUNICATIONSIMPLE_ITEM_MODIFIABLE_DATA_TYPE_INT16_2_FLOAT                                     15
#define TS_COMMUNICATIONSIMPLE_ITEM_MODIFIABLE_DATA_TYPE_UINT8_2_INT32                                     16
#define TS_COMMUNICATIONSIMPLE_ITEM_MODIFIABLE_DATA_TYPE_UINT8_2_FLOAT                                     17
#define TS_COMMUNICATIONSIMPLE_ITEM_MODIFIABLE_DATA_TYPE_INT8_2_INT32                                      18
#define TS_COMMUNICATIONSIMPLE_ITEM_MODIFIABLE_DATA_TYPE_INT8_2_FLOAT                                      19
#define TS_COMMUNICATIONSIMPLE_ITEM_MODIFIABLE_DATA_TYPE_COUNT_                                            20
//      ConfigurationCommunicationSimpleItem_modifiable_TS.channel_bus_override
#define TS_COMMUNICATIONSIMPLE_ITEM_MODIFIABLE_CHANNEL_BUS_OVERRIDE_BUS_TYPE_SHIFT                         0
#define TS_COMMUNICATIONSIMPLE_ITEM_MODIFIABLE_CHANNEL_BUS_OVERRIDE_BUS_TYPE_MASK                          0x01
#define TS_COMMUNICATIONSIMPLE_ITEM_MODIFIABLE_CHANNEL_BUS_OVERRIDE_BUS_TYPE_CAN                           0x00
#define TS_COMMUNICATIONSIMPLE_ITEM_MODIFIABLE_CHANNEL_BUS_OVERRIDE_BUS_TYPE_SERIAL                        0x01
#define TS_COMMUNICATIONSIMPLE_ITEM_MODIFIABLE_CHANNEL_BUS_OVERRIDE_BUS_TYPE_COUNT_                        2
#define TS_COMMUNICATIONSIMPLE_ITEM_MODIFIABLE_CHANNEL_BUS_OVERRIDE_BUS_CHANNEL_SHIFT                      1
#define TS_COMMUNICATIONSIMPLE_ITEM_MODIFIABLE_CHANNEL_BUS_OVERRIDE_BUS_CHANNEL_MASK                       0x02
#define TS_COMMUNICATIONSIMPLE_ITEM_MODIFIABLE_CHANNEL_BUS_OVERRIDE_BUS_CHANNEL_CHANNELA                   0x00
#define TS_COMMUNICATIONSIMPLE_ITEM_MODIFIABLE_CHANNEL_BUS_OVERRIDE_BUS_CHANNEL_CHANNELB                   0x02
#define TS_COMMUNICATIONSIMPLE_ITEM_MODIFIABLE_CHANNEL_BUS_OVERRIDE_BUS_CHANNEL_COUNT_                     2
#define TS_COMMUNICATIONSIMPLE_ITEM_MODIFIABLE_CHANNEL_BUS_OVERRIDE_BUS_DIRECTION_SHIFT                    2
#define TS_COMMUNICATIONSIMPLE_ITEM_MODIFIABLE_CHANNEL_BUS_OVERRIDE_BUS_DIRECTION_MASK                     0x04
#define TS_COMMUNICATIONSIMPLE_ITEM_MODIFIABLE_CHANNEL_BUS_OVERRIDE_BUS_DIRECTION_TRANSMIT                 0x00
#define TS_COMMUNICATIONSIMPLE_ITEM_MODIFIABLE_CHANNEL_BUS_OVERRIDE_BUS_DIRECTION_RECEIVE                  0x04
#define TS_COMMUNICATIONSIMPLE_ITEM_MODIFIABLE_CHANNEL_BUS_OVERRIDE_BUS_DIRECTION_COUNT_                   2
#define TS_COMMUNICATIONSIMPLE_ITEM_MODIFIABLE_CHANNEL_BUS_OVERRIDE_CAN_TYPE_SHIFT                         3
#define TS_COMMUNICATIONSIMPLE_ITEM_MODIFIABLE_CHANNEL_BUS_OVERRIDE_CAN_TYPE_MASK                          0x08
#define TS_COMMUNICATIONSIMPLE_ITEM_MODIFIABLE_CHANNEL_BUS_OVERRIDE_CAN_TYPE_STANDARD_FORMAT               0x00
#define TS_COMMUNICATIONSIMPLE_ITEM_MODIFIABLE_CHANNEL_BUS_OVERRIDE_CAN_TYPE_EXTENDED_FORMAT               0x08
#define TS_COMMUNICATIONSIMPLE_ITEM_MODIFIABLE_CHANNEL_BUS_OVERRIDE_CAN_TYPE_COUNT_                        2
#define TS_COMMUNICATIONSIMPLE_ITEM_MODIFIABLE_CHANNEL_BUS_OVERRIDE_CAN_8BYTE_PER_CONTIGUOUS_ADDRESS_SHIFT 4
#define TS_COMMUNICATIONSIMPLE_ITEM_MODIFIABLE_CHANNEL_BUS_OVERRIDE_CAN_8BYTE_PER_CONTIGUOUS_ADDRESS_MASK  0x10
#define TS_COMMUNICATIONSIMPLE_ITEM_MODIFIABLE_CHANNEL_BUS_OVERRIDE_CAN_8BYTE_PER_CONTIGUOUS_ADDRESS__     0x10
#define TS_COMMUNICATIONSIMPLE_ITEM_MODIFIABLE_CHANNEL_BUS_OVERRIDE_INPUT_OVERRIDE_SHIFT                   5
#define TS_COMMUNICATIONSIMPLE_ITEM_MODIFIABLE_CHANNEL_BUS_OVERRIDE_INPUT_OVERRIDE_MASK                    0x20
#define TS_COMMUNICATIONSIMPLE_ITEM_MODIFIABLE_CHANNEL_BUS_OVERRIDE_INPUT_OVERRIDE__                       0x20
//      ConfigurationCommunicationSimpleItem_modifiable_TS.id_dataformat
#define TS_COMMUNICATIONSIMPLE_ITEM_MODIFIABLE_ID_DATAFORMAT_DATA_BITS_SHIFT                               0
#define TS_COMMUNICATIONSIMPLE_ITEM_MODIFIABLE_ID_DATAFORMAT_DATA_BITS_MASK                                0x00000003
#define TS_COMMUNICATIONSIMPLE_ITEM_MODIFIABLE_ID_DATAFORMAT_DATA_BITS_BITS7                               0x00000000
#define TS_COMMUNICATIONSIMPLE_ITEM_MODIFIABLE_ID_DATAFORMAT_DATA_BITS_BITS8                               0x00000001
#define TS_COMMUNICATIONSIMPLE_ITEM_MODIFIABLE_ID_DATAFORMAT_DATA_BITS_COUNT_                              2
#define TS_COMMUNICATIONSIMPLE_ITEM_MODIFIABLE_ID_DATAFORMAT_PARITY_SHIFT                                  2
#define TS_COMMUNICATIONSIMPLE_ITEM_MODIFIABLE_ID_DATAFORMAT_PARITY_MASK                                   0x0000000C
#define TS_COMMUNICATIONSIMPLE_ITEM_MODIFIABLE_ID_DATAFORMAT_PARITY_PARITY_NONE                            0x00000000
#define TS_COMMUNICATIONSIMPLE_ITEM_MODIFIABLE_ID_DATAFORMAT_PARITY_PARITY_EVEN                            0x00000004
#define TS_COMMUNICATIONSIMPLE_ITEM_MODIFIABLE_ID_DATAFORMAT_PARITY_PARITY_ODD                             0x00000008
#define TS_COMMUNICATIONSIMPLE_ITEM_MODIFIABLE_ID_DATAFORMAT_PARITY_COUNT_                                 3
#define TS_COMMUNICATIONSIMPLE_ITEM_MODIFIABLE_ID_DATAFORMAT_STOP_BITS_SHIFT                               4
#define TS_COMMUNICATIONSIMPLE_ITEM_MODIFIABLE_ID_DATAFORMAT_STOP_BITS_MASK                                0x00000010
#define TS_COMMUNICATIONSIMPLE_ITEM_MODIFIABLE_ID_DATAFORMAT_STOP_BITS_STOPBITS1                           0x00000000
#define TS_COMMUNICATIONSIMPLE_ITEM_MODIFIABLE_ID_DATAFORMAT_STOP_BITS_STOPBITS2                           0x00000010
#define TS_COMMUNICATIONSIMPLE_ITEM_MODIFIABLE_ID_DATAFORMAT_STOP_BITS_COUNT_                              2
#define TS_COMMUNICATIONSIMPLE_ITEM_MODIFIABLE_ID_DATAFORMAT_PCLK_DIV_SHIFT                                5
#define TS_COMMUNICATIONSIMPLE_ITEM_MODIFIABLE_ID_DATAFORMAT_PCLK_DIV_MASK                                 0x00000060
#define TS_COMMUNICATIONSIMPLE_ITEM_MODIFIABLE_ID_DATAFORMAT_PCLK_DIV_PCLK_DIV_1                           0x00000000
#define TS_COMMUNICATIONSIMPLE_ITEM_MODIFIABLE_ID_DATAFORMAT_PCLK_DIV_PCLK_DIV_4                           0x00000020
#define TS_COMMUNICATIONSIMPLE_ITEM_MODIFIABLE_ID_DATAFORMAT_PCLK_DIV_PCLK_DIV_16                          0x00000040
#define TS_COMMUNICATIONSIMPLE_ITEM_MODIFIABLE_ID_DATAFORMAT_PCLK_DIV_PCLK_DIV_64                          0x00000060
#define TS_COMMUNICATIONSIMPLE_ITEM_MODIFIABLE_ID_DATAFORMAT_PCLK_DIV_COUNT_                               4
#define TS_COMMUNICATIONSIMPLE_ITEM_MODIFIABLE_ID_DATAFORMAT_BAUDRATEGEN_N_SHIFT                           8
#define TS_COMMUNICATIONSIMPLE_ITEM_MODIFIABLE_ID_DATAFORMAT_BAUDRATEGEN_N_MASK                            0x0000FF00
#define TS_COMMUNICATIONSIMPLE_ITEM_MODIFIABLE_ID_DATAFORMAT_CAN_ID_SHIFT                                  0
#define TS_COMMUNICATIONSIMPLE_ITEM_MODIFIABLE_ID_DATAFORMAT_CAN_ID_MASK                                   0xFFFFFFFF
typedef struct tag_ConfigurationCommunicationSimpleItem_modifiable_TS {
    ConfigurationItemHeader_modifiable_TS header;
    BYTE channel_bus_override;
    DWORD id_dataformat;
    GenericArray_DTS input_overrides;
    GenericArray_DTS data_type;
    GenericArray_DTS data_min_value;
    GenericArray_DTS data_max_value;
    GenericArray_DTS data_buffer;
}ConfigurationCommunicationSimpleItem_modifiable_TS, *pConfigurationCommunicationSimpleItem_modifiable_TS;

typedef struct tag_ConfigurationModelIDItem_modifiable_TS {
    ConfigurationItemHeader_modifiable_TS header;
    GenericArray_DTS str0;
    GenericArray_DTS str1;
    GenericArray_DTS str2;
    GenericArray_DTS str3;
}ConfigurationModelIDItem_modifiable_TS, *pConfigurationModelIDItem_modifiable_TS;

//      ConfigurationCANPacketItem_modifiable_TS.data_type
#define TS_CANPACKET_ITEM_MODIFIABLE_DATA_TYPE_FLOAT_2_INT8                      0
#define TS_CANPACKET_ITEM_MODIFIABLE_DATA_TYPE_FLOAT_2_INT16                     1
#define TS_CANPACKET_ITEM_MODIFIABLE_DATA_TYPE_FLOAT_2_INT32                     2
#define TS_CANPACKET_ITEM_MODIFIABLE_DATA_TYPE_FLOAT_2_FLOAT                     3
#define TS_CANPACKET_ITEM_MODIFIABLE_DATA_TYPE_UINT32_2_INT8                     4
#define TS_CANPACKET_ITEM_MODIFIABLE_DATA_TYPE_UINT32_2_INT16                    5
#define TS_CANPACKET_ITEM_MODIFIABLE_DATA_TYPE_UINT32_2_INT32                    6
#define TS_CANPACKET_ITEM_MODIFIABLE_DATA_TYPE_UINT32_2_FLOAT                    7
#define TS_CANPACKET_ITEM_MODIFIABLE_DATA_TYPE_INT32_2_INT8                      8
#define TS_CANPACKET_ITEM_MODIFIABLE_DATA_TYPE_INT32_2_INT16                     9
#define TS_CANPACKET_ITEM_MODIFIABLE_DATA_TYPE_INT32_2_INT32                     10
#define TS_CANPACKET_ITEM_MODIFIABLE_DATA_TYPE_INT32_2_FLOAT                     11
#define TS_CANPACKET_ITEM_MODIFIABLE_DATA_TYPE_UINT16_2_INT32                    12
#define TS_CANPACKET_ITEM_MODIFIABLE_DATA_TYPE_UINT16_2_FLOAT                    13
#define TS_CANPACKET_ITEM_MODIFIABLE_DATA_TYPE_INT16_2_INT32                     14
#define TS_CANPACKET_ITEM_MODIFIABLE_DATA_TYPE_INT16_2_FLOAT                     15
#define TS_CANPACKET_ITEM_MODIFIABLE_DATA_TYPE_UINT8_2_INT32                     16
#define TS_CANPACKET_ITEM_MODIFIABLE_DATA_TYPE_UINT8_2_FLOAT                     17
#define TS_CANPACKET_ITEM_MODIFIABLE_DATA_TYPE_INT8_2_INT32                      18
#define TS_CANPACKET_ITEM_MODIFIABLE_DATA_TYPE_INT8_2_FLOAT                      19
#define TS_CANPACKET_ITEM_MODIFIABLE_DATA_TYPE_FLOAT_2_UINT8                     20
#define TS_CANPACKET_ITEM_MODIFIABLE_DATA_TYPE_FLOAT_2_UINT16                    21
#define TS_CANPACKET_ITEM_MODIFIABLE_DATA_TYPE_FLOAT_2_UINT32                    22
#define TS_CANPACKET_ITEM_MODIFIABLE_DATA_TYPE_FLOAT_2_SIGNMAG8                  23
#define TS_CANPACKET_ITEM_MODIFIABLE_DATA_TYPE_FLOAT_2_SIGNMAG16                 24
#define TS_CANPACKET_ITEM_MODIFIABLE_DATA_TYPE_FLOAT_2_SIGNMAG32                 25
#define TS_CANPACKET_ITEM_MODIFIABLE_DATA_TYPE_SIGNMAG8_2_FLOAT                  26
#define TS_CANPACKET_ITEM_MODIFIABLE_DATA_TYPE_SIGNMAG16_2_FLOAT                 27
#define TS_CANPACKET_ITEM_MODIFIABLE_DATA_TYPE_SIGNMAG32_2_FLOAT                 28
#define TS_CANPACKET_ITEM_MODIFIABLE_DATA_TYPE_COUNT_                            29
//      ConfigurationCANPacketItem_modifiable_TS.channel_bus_override
#define TS_CANPACKET_ITEM_MODIFIABLE_CHANNEL_BUS_OVERRIDE_BUS_CHANNEL_SHIFT      1
#define TS_CANPACKET_ITEM_MODIFIABLE_CHANNEL_BUS_OVERRIDE_BUS_CHANNEL_MASK       0x02
#define TS_CANPACKET_ITEM_MODIFIABLE_CHANNEL_BUS_OVERRIDE_BUS_CHANNEL_CHANNELA   0x00
#define TS_CANPACKET_ITEM_MODIFIABLE_CHANNEL_BUS_OVERRIDE_BUS_CHANNEL_CHANNELB   0x02
#define TS_CANPACKET_ITEM_MODIFIABLE_CHANNEL_BUS_OVERRIDE_BUS_CHANNEL_COUNT_     2
#define TS_CANPACKET_ITEM_MODIFIABLE_CHANNEL_BUS_OVERRIDE_BUS_DIRECTION_SHIFT    2
#define TS_CANPACKET_ITEM_MODIFIABLE_CHANNEL_BUS_OVERRIDE_BUS_DIRECTION_MASK     0x04
#define TS_CANPACKET_ITEM_MODIFIABLE_CHANNEL_BUS_OVERRIDE_BUS_DIRECTION_TRANSMIT 0x00
#define TS_CANPACKET_ITEM_MODIFIABLE_CHANNEL_BUS_OVERRIDE_BUS_DIRECTION_RECEIVE  0x04
#define TS_CANPACKET_ITEM_MODIFIABLE_CHANNEL_BUS_OVERRIDE_BUS_DIRECTION_COUNT_   2
#define TS_CANPACKET_ITEM_MODIFIABLE_CHANNEL_BUS_OVERRIDE_MODE_TX_SHIFT          3
#define TS_CANPACKET_ITEM_MODIFIABLE_CHANNEL_BUS_OVERRIDE_MODE_TX_MASK           0x08
#define TS_CANPACKET_ITEM_MODIFIABLE_CHANNEL_BUS_OVERRIDE_MODE_TX_PERIODIC       0x00
#define TS_CANPACKET_ITEM_MODIFIABLE_CHANNEL_BUS_OVERRIDE_MODE_TX_EVENT          0x08
#define TS_CANPACKET_ITEM_MODIFIABLE_CHANNEL_BUS_OVERRIDE_MODE_TX_COUNT_         2
//      ConfigurationCANPacketItem_modifiable_TS.event_latch
#define TS_CANPACKET_ITEM_MODIFIABLE_EVENT_LATCH_EDGE_SHIFT                      0
#define TS_CANPACKET_ITEM_MODIFIABLE_EVENT_LATCH_EDGE_MASK                       0x03
#define TS_CANPACKET_ITEM_MODIFIABLE_EVENT_LATCH_EDGE_RISING_EDGE                0x01
#define TS_CANPACKET_ITEM_MODIFIABLE_EVENT_LATCH_EDGE_FALLING_EDGE               0x02
#define TS_CANPACKET_ITEM_MODIFIABLE_EVENT_LATCH_START_STATE_SHIFT               4
#define TS_CANPACKET_ITEM_MODIFIABLE_EVENT_LATCH_START_STATE_MASK                0x30
#define TS_CANPACKET_ITEM_MODIFIABLE_EVENT_LATCH_START_STATE_ZERO                0x00
#define TS_CANPACKET_ITEM_MODIFIABLE_EVENT_LATCH_START_STATE_NON_ZERO            0x10
#define TS_CANPACKET_ITEM_MODIFIABLE_EVENT_LATCH_START_STATE_COUNT_              2
#define TS_CANPACKET_ITEM_MODIFIABLE_EVENT_LATCH_INITIALIZED_SHIFT               6
#define TS_CANPACKET_ITEM_MODIFIABLE_EVENT_LATCH_INITIALIZED_MASK                0x40
#define TS_CANPACKET_ITEM_MODIFIABLE_EVENT_LATCH_INITIALIZED__                   0x40
#define TS_CANPACKET_ITEM_MODIFIABLE_EVENT_LATCH_RX_DT_SHIFT                     7
#define TS_CANPACKET_ITEM_MODIFIABLE_EVENT_LATCH_RX_DT_MASK                      0x80
#define TS_CANPACKET_ITEM_MODIFIABLE_EVENT_LATCH_RX_DT__                         0x80
typedef struct tag_ConfigurationCANPacketItem_modifiable_TS {
    ConfigurationItemHeader_modifiable_TS header;
    GenericArray_DTS addresses;
    GenericArray_DTS data_min_value;
    GenericArray_DTS data_max_value;
    GenericArray_DTS internal_input_data_pointers;
    GenericArray_DTS internal_inputs;
    GenericArray_DTS suggested_iteration_count;
    GenericArray_DTS data_shift;
    GenericArray_DTS data_bits;
    GenericArray_DTS data_type;
    BYTE channel_bus_override;
    BYTE event_latch;
}ConfigurationCANPacketItem_modifiable_TS, *pConfigurationCANPacketItem_modifiable_TS;

//      ConfigurationSerialStreamItem_modifiable_TS.data_type
#define TS_SERIALSTREAM_ITEM_MODIFIABLE_DATA_TYPE_FLOAT_2_INT8                      0
#define TS_SERIALSTREAM_ITEM_MODIFIABLE_DATA_TYPE_FLOAT_2_INT16                     1
#define TS_SERIALSTREAM_ITEM_MODIFIABLE_DATA_TYPE_FLOAT_2_INT32                     2
#define TS_SERIALSTREAM_ITEM_MODIFIABLE_DATA_TYPE_FLOAT_2_FLOAT                     3
#define TS_SERIALSTREAM_ITEM_MODIFIABLE_DATA_TYPE_UINT32_2_INT8                     4
#define TS_SERIALSTREAM_ITEM_MODIFIABLE_DATA_TYPE_UINT32_2_INT16                    5
#define TS_SERIALSTREAM_ITEM_MODIFIABLE_DATA_TYPE_UINT32_2_INT32                    6
#define TS_SERIALSTREAM_ITEM_MODIFIABLE_DATA_TYPE_UINT32_2_FLOAT                    7
#define TS_SERIALSTREAM_ITEM_MODIFIABLE_DATA_TYPE_INT32_2_INT8                      8
#define TS_SERIALSTREAM_ITEM_MODIFIABLE_DATA_TYPE_INT32_2_INT16                     9
#define TS_SERIALSTREAM_ITEM_MODIFIABLE_DATA_TYPE_INT32_2_INT32                     10
#define TS_SERIALSTREAM_ITEM_MODIFIABLE_DATA_TYPE_INT32_2_FLOAT                     11
#define TS_SERIALSTREAM_ITEM_MODIFIABLE_DATA_TYPE_UINT16_2_INT32                    12
#define TS_SERIALSTREAM_ITEM_MODIFIABLE_DATA_TYPE_UINT16_2_FLOAT                    13
#define TS_SERIALSTREAM_ITEM_MODIFIABLE_DATA_TYPE_INT16_2_INT32                     14
#define TS_SERIALSTREAM_ITEM_MODIFIABLE_DATA_TYPE_INT16_2_FLOAT                     15
#define TS_SERIALSTREAM_ITEM_MODIFIABLE_DATA_TYPE_UINT8_2_INT32                     16
#define TS_SERIALSTREAM_ITEM_MODIFIABLE_DATA_TYPE_UINT8_2_FLOAT                     17
#define TS_SERIALSTREAM_ITEM_MODIFIABLE_DATA_TYPE_INT8_2_INT32                      18
#define TS_SERIALSTREAM_ITEM_MODIFIABLE_DATA_TYPE_INT8_2_FLOAT                      19
#define TS_SERIALSTREAM_ITEM_MODIFIABLE_DATA_TYPE_FLOAT_2_UINT8                     20
#define TS_SERIALSTREAM_ITEM_MODIFIABLE_DATA_TYPE_FLOAT_2_UINT16                    21
#define TS_SERIALSTREAM_ITEM_MODIFIABLE_DATA_TYPE_FLOAT_2_UINT32                    22
#define TS_SERIALSTREAM_ITEM_MODIFIABLE_DATA_TYPE_FLOAT_2_SIGNMAG8                  23
#define TS_SERIALSTREAM_ITEM_MODIFIABLE_DATA_TYPE_FLOAT_2_SIGNMAG16                 24
#define TS_SERIALSTREAM_ITEM_MODIFIABLE_DATA_TYPE_FLOAT_2_SIGNMAG32                 25
#define TS_SERIALSTREAM_ITEM_MODIFIABLE_DATA_TYPE_SIGNMAG8_2_FLOAT                  26
#define TS_SERIALSTREAM_ITEM_MODIFIABLE_DATA_TYPE_SIGNMAG16_2_FLOAT                 27
#define TS_SERIALSTREAM_ITEM_MODIFIABLE_DATA_TYPE_SIGNMAG32_2_FLOAT                 28
#define TS_SERIALSTREAM_ITEM_MODIFIABLE_DATA_TYPE_COUNT_                            29
//      ConfigurationSerialStreamItem_modifiable_TS.data_format
#define TS_SERIALSTREAM_ITEM_MODIFIABLE_DATA_FORMAT_DATA_BITS_SHIFT                 0
#define TS_SERIALSTREAM_ITEM_MODIFIABLE_DATA_FORMAT_DATA_BITS_MASK                  0x00000003
#define TS_SERIALSTREAM_ITEM_MODIFIABLE_DATA_FORMAT_DATA_BITS_BITS7                 0x00000000
#define TS_SERIALSTREAM_ITEM_MODIFIABLE_DATA_FORMAT_DATA_BITS_BITS8                 0x00000001
#define TS_SERIALSTREAM_ITEM_MODIFIABLE_DATA_FORMAT_DATA_BITS_COUNT_                2
#define TS_SERIALSTREAM_ITEM_MODIFIABLE_DATA_FORMAT_PARITY_SHIFT                    2
#define TS_SERIALSTREAM_ITEM_MODIFIABLE_DATA_FORMAT_PARITY_MASK                     0x0000000C
#define TS_SERIALSTREAM_ITEM_MODIFIABLE_DATA_FORMAT_PARITY_PARITY_NONE              0x00000000
#define TS_SERIALSTREAM_ITEM_MODIFIABLE_DATA_FORMAT_PARITY_PARITY_EVEN              0x00000004
#define TS_SERIALSTREAM_ITEM_MODIFIABLE_DATA_FORMAT_PARITY_PARITY_ODD               0x00000008
#define TS_SERIALSTREAM_ITEM_MODIFIABLE_DATA_FORMAT_PARITY_COUNT_                   3
#define TS_SERIALSTREAM_ITEM_MODIFIABLE_DATA_FORMAT_STOP_BITS_SHIFT                 4
#define TS_SERIALSTREAM_ITEM_MODIFIABLE_DATA_FORMAT_STOP_BITS_MASK                  0x00000010
#define TS_SERIALSTREAM_ITEM_MODIFIABLE_DATA_FORMAT_STOP_BITS_STOPBITS1             0x00000000
#define TS_SERIALSTREAM_ITEM_MODIFIABLE_DATA_FORMAT_STOP_BITS_STOPBITS2             0x00000010
#define TS_SERIALSTREAM_ITEM_MODIFIABLE_DATA_FORMAT_STOP_BITS_COUNT_                2
#define TS_SERIALSTREAM_ITEM_MODIFIABLE_DATA_FORMAT_PCLK_DIV_SHIFT                  5
#define TS_SERIALSTREAM_ITEM_MODIFIABLE_DATA_FORMAT_PCLK_DIV_MASK                   0x00000060
#define TS_SERIALSTREAM_ITEM_MODIFIABLE_DATA_FORMAT_PCLK_DIV_PCLK_DIV_1             0x00000000
#define TS_SERIALSTREAM_ITEM_MODIFIABLE_DATA_FORMAT_PCLK_DIV_PCLK_DIV_4             0x00000020
#define TS_SERIALSTREAM_ITEM_MODIFIABLE_DATA_FORMAT_PCLK_DIV_PCLK_DIV_16            0x00000040
#define TS_SERIALSTREAM_ITEM_MODIFIABLE_DATA_FORMAT_PCLK_DIV_PCLK_DIV_64            0x00000060
#define TS_SERIALSTREAM_ITEM_MODIFIABLE_DATA_FORMAT_PCLK_DIV_COUNT_                 4
#define TS_SERIALSTREAM_ITEM_MODIFIABLE_DATA_FORMAT_BAUDRATEGEN_N_SHIFT             8
#define TS_SERIALSTREAM_ITEM_MODIFIABLE_DATA_FORMAT_BAUDRATEGEN_N_MASK              0x0000FF00
//      ConfigurationSerialStreamItem_modifiable_TS.event_latch
#define TS_SERIALSTREAM_ITEM_MODIFIABLE_EVENT_LATCH_EDGE_SHIFT                      0
#define TS_SERIALSTREAM_ITEM_MODIFIABLE_EVENT_LATCH_EDGE_MASK                       0x03
#define TS_SERIALSTREAM_ITEM_MODIFIABLE_EVENT_LATCH_EDGE_RISING_EDGE                0x01
#define TS_SERIALSTREAM_ITEM_MODIFIABLE_EVENT_LATCH_EDGE_FALLING_EDGE               0x02
#define TS_SERIALSTREAM_ITEM_MODIFIABLE_EVENT_LATCH_START_STATE_SHIFT               4
#define TS_SERIALSTREAM_ITEM_MODIFIABLE_EVENT_LATCH_START_STATE_MASK                0x30
#define TS_SERIALSTREAM_ITEM_MODIFIABLE_EVENT_LATCH_START_STATE_ZERO                0x00
#define TS_SERIALSTREAM_ITEM_MODIFIABLE_EVENT_LATCH_START_STATE_NON_ZERO            0x10
#define TS_SERIALSTREAM_ITEM_MODIFIABLE_EVENT_LATCH_START_STATE_COUNT_              2
#define TS_SERIALSTREAM_ITEM_MODIFIABLE_EVENT_LATCH_INITIALIZED_SHIFT               6
#define TS_SERIALSTREAM_ITEM_MODIFIABLE_EVENT_LATCH_INITIALIZED_MASK                0x40
#define TS_SERIALSTREAM_ITEM_MODIFIABLE_EVENT_LATCH_INITIALIZED__                   0x40
//      ConfigurationSerialStreamItem_modifiable_TS.channel_bus_override
#define TS_SERIALSTREAM_ITEM_MODIFIABLE_CHANNEL_BUS_OVERRIDE_BUS_CHANNEL_SHIFT      1
#define TS_SERIALSTREAM_ITEM_MODIFIABLE_CHANNEL_BUS_OVERRIDE_BUS_CHANNEL_MASK       0x02
#define TS_SERIALSTREAM_ITEM_MODIFIABLE_CHANNEL_BUS_OVERRIDE_BUS_CHANNEL_CHANNELA   0x00
#define TS_SERIALSTREAM_ITEM_MODIFIABLE_CHANNEL_BUS_OVERRIDE_BUS_CHANNEL_CHANNELB   0x02
#define TS_SERIALSTREAM_ITEM_MODIFIABLE_CHANNEL_BUS_OVERRIDE_BUS_CHANNEL_COUNT_     2
#define TS_SERIALSTREAM_ITEM_MODIFIABLE_CHANNEL_BUS_OVERRIDE_BUS_DIRECTION_SHIFT    2
#define TS_SERIALSTREAM_ITEM_MODIFIABLE_CHANNEL_BUS_OVERRIDE_BUS_DIRECTION_MASK     0x04
#define TS_SERIALSTREAM_ITEM_MODIFIABLE_CHANNEL_BUS_OVERRIDE_BUS_DIRECTION_TRANSMIT 0x00
#define TS_SERIALSTREAM_ITEM_MODIFIABLE_CHANNEL_BUS_OVERRIDE_BUS_DIRECTION_RECEIVE  0x04
#define TS_SERIALSTREAM_ITEM_MODIFIABLE_CHANNEL_BUS_OVERRIDE_BUS_DIRECTION_COUNT_   2
#define TS_SERIALSTREAM_ITEM_MODIFIABLE_CHANNEL_BUS_OVERRIDE_MODE_TX_SHIFT          3
#define TS_SERIALSTREAM_ITEM_MODIFIABLE_CHANNEL_BUS_OVERRIDE_MODE_TX_MASK           0x08
#define TS_SERIALSTREAM_ITEM_MODIFIABLE_CHANNEL_BUS_OVERRIDE_MODE_TX_PERIODIC       0x00
#define TS_SERIALSTREAM_ITEM_MODIFIABLE_CHANNEL_BUS_OVERRIDE_MODE_TX_EVENT          0x08
#define TS_SERIALSTREAM_ITEM_MODIFIABLE_CHANNEL_BUS_OVERRIDE_MODE_TX_COUNT_         2
typedef struct tag_ConfigurationSerialStreamItem_modifiable_TS {
    ConfigurationItemHeader_modifiable_TS header;
    GenericArray_DTS internal_inputs;
    GenericArray_DTS internal_input_data_pointers;
    GenericArray_DTS data_min_value;
    GenericArray_DTS data_max_value;
    GenericArray_DTS data_shift;
    GenericArray_DTS data_bits;
    GenericArray_DTS data_valid;
    GenericArray_DTS data_type;
    DWORD data_format;
    GenericArray_DTS data_buffer;
    WORD stream_length;
    BYTE event_latch;
    BYTE channel_bus_override;
}ConfigurationSerialStreamItem_modifiable_TS, *pConfigurationSerialStreamItem_modifiable_TS;

typedef struct tag_ConfigurationEngineTimingGeneratorItem_modifiable_TS {
    ConfigurationItemHeader_modifiable_TS header;
}ConfigurationEngineTimingGeneratorItem_modifiable_TS, *pConfigurationEngineTimingGeneratorItem_modifiable_TS;

typedef struct tag_ConfigurationHwPlaceHolderItem_modifiable_TS {
    ConfigurationItemHeader_modifiable_TS header;
}ConfigurationHwPlaceHolderItem_modifiable_TS, *pConfigurationHwPlaceHolderItem_modifiable_TS;

typedef struct tag_ConfigurationCJ125V2Item_modifiable_TS {
    ConfigurationItemHeader_modifiable_TS header;
}ConfigurationCJ125V2Item_modifiable_TS, *pConfigurationCJ125V2Item_modifiable_TS;

//      ConfigurationNMEA2000InterfaceItem_modifiable_TS.channel_bus_override
#define TS_NMEA2000INTERFACE_ITEM_MODIFIABLE_CHANNEL_BUS_OVERRIDE_BUS_CHANNEL_SHIFT    1
#define TS_NMEA2000INTERFACE_ITEM_MODIFIABLE_CHANNEL_BUS_OVERRIDE_BUS_CHANNEL_MASK     0x02
#define TS_NMEA2000INTERFACE_ITEM_MODIFIABLE_CHANNEL_BUS_OVERRIDE_BUS_CHANNEL_CHANNELA 0x00
#define TS_NMEA2000INTERFACE_ITEM_MODIFIABLE_CHANNEL_BUS_OVERRIDE_BUS_CHANNEL_CHANNELB 0x02
#define TS_NMEA2000INTERFACE_ITEM_MODIFIABLE_CHANNEL_BUS_OVERRIDE_BUS_CHANNEL_COUNT_   2
#define TS_NMEA2000INTERFACE_ITEM_MODIFIABLE_CHANNEL_BUS_OVERRIDE_MODE_TX_SHIFT        3
#define TS_NMEA2000INTERFACE_ITEM_MODIFIABLE_CHANNEL_BUS_OVERRIDE_MODE_TX_MASK         0x08
#define TS_NMEA2000INTERFACE_ITEM_MODIFIABLE_CHANNEL_BUS_OVERRIDE_MODE_TX_PERIODIC     0x00
#define TS_NMEA2000INTERFACE_ITEM_MODIFIABLE_CHANNEL_BUS_OVERRIDE_MODE_TX_EVENT        0x08
#define TS_NMEA2000INTERFACE_ITEM_MODIFIABLE_CHANNEL_BUS_OVERRIDE_MODE_TX_COUNT_       2
//      ConfigurationNMEA2000InterfaceItem_modifiable_TS.event_latch
#define TS_NMEA2000INTERFACE_ITEM_MODIFIABLE_EVENT_LATCH_EDGE_SHIFT                    0
#define TS_NMEA2000INTERFACE_ITEM_MODIFIABLE_EVENT_LATCH_EDGE_MASK                     0x03
#define TS_NMEA2000INTERFACE_ITEM_MODIFIABLE_EVENT_LATCH_EDGE_RISING_EDGE              0x01
#define TS_NMEA2000INTERFACE_ITEM_MODIFIABLE_EVENT_LATCH_EDGE_FALLING_EDGE             0x02
#define TS_NMEA2000INTERFACE_ITEM_MODIFIABLE_EVENT_LATCH_START_STATE_SHIFT             4
#define TS_NMEA2000INTERFACE_ITEM_MODIFIABLE_EVENT_LATCH_START_STATE_MASK              0x30
#define TS_NMEA2000INTERFACE_ITEM_MODIFIABLE_EVENT_LATCH_START_STATE_ZERO              0x00
#define TS_NMEA2000INTERFACE_ITEM_MODIFIABLE_EVENT_LATCH_START_STATE_NON_ZERO          0x10
#define TS_NMEA2000INTERFACE_ITEM_MODIFIABLE_EVENT_LATCH_START_STATE_COUNT_            2
#define TS_NMEA2000INTERFACE_ITEM_MODIFIABLE_EVENT_LATCH_INITIALIZED_SHIFT             6
#define TS_NMEA2000INTERFACE_ITEM_MODIFIABLE_EVENT_LATCH_INITIALIZED_MASK              0x40
#define TS_NMEA2000INTERFACE_ITEM_MODIFIABLE_EVENT_LATCH_INITIALIZED__                 0x40
typedef struct tag_ConfigurationNMEA2000InterfaceItem_modifiable_TS {
    ConfigurationItemHeader_modifiable_TS header;
    BYTE channel_bus_override;
    BYTE event_latch;
}ConfigurationNMEA2000InterfaceItem_modifiable_TS, *pConfigurationNMEA2000InterfaceItem_modifiable_TS;

#define BLACKFOOT_J8 0
#define BLACKFOOT_J9 35
#define BLACKFOOT_J10 70
#define BITTERROOT_CONNECTOR1 0
#define BITTERROOT_CONNECTOR2 35
#define BITTERROOT_CONNECTOR3 70
#define BITTERROOT_CONNECTOR4 105
#define BITTERROOT2_CONNECTOR1 0
#define BITTERROOT2_CONNECTOR2 35
#define BITTERROOT2_CONNECTOR3 70
#define BITTERROOT2_CONNECTOR4 105
#define MORESBY_CONNECTOR1 0
#define MORESBY_CONNECTOR2 48
#define MORESBY_COLA 0
#define MORESBY_COLB 4
#define MORESBY_COLC 8
#define MORESBY_COLD 12
#define MORESBY_COLE 16
#define MORESBY_COLF 20
#define MORESBY_COLG 24
#define MORESBY_COLH 28
#define MORESBY_COLJ 32
#define MORESBY_COLK 36
#define MORESBY_COLL 40
#define MORESBY_COLM 44
#define INFINITY10_CONNECTOR1 0
#define INFINITY10_CONNECTOR2 72
#define VENICE_CONNECTOR 0
#define HUDSON_CONNECTOR1 0
#define HUDSON_CONNECTOR2 72
// Application channel defines.
#define CM_APPLICATION_SETTINGS_KEY_OFF_COMMIT 1
// Engine sync response values.
#define TS_ENGINEDESCRIPTOR_ITEM_EAL_SYNC_RESPONSE_IGNORE 0
#define TS_ENGINEDESCRIPTOR_ITEM_EAL_SYNC_RESPONSE_RESYNC 1
#define TS_ENGINEDESCRIPTOR_ITEM_EAL_SYNC_RESPONSE_SHUTDOWN 2

/*** Structures ***/
# endif //_TRANSFERSTRUCTS_H_

#define UHC_HOOK_NOT_GRANTED -1
#define UHC_AFTER_NOT_CALLED -2
#define UHC_HOOK_SUPPORTED 0
#define UHC_BEFORE_UPGRADE 10
#define UHC_AFTER_UPGRADE 11
#define UHC_BEFORE_IMPORT 12
#define UHC_AFTER_IMPORT 13
// This status is reserved for main program use only.  No plugin shall return this value.
#define UHS_RESERVED -1
#define UHS_SUCCESS 0
#define UHS_YES UHS_SUCCESS
#define UHS_DONE UHS_SUCCESS
#define UHS_MODEL_HANDLED UHS_SUCCESS
#define UHS_CONTINUE UHS_SUCCESS
#define UHS_ABORT 1
#define UHS_FAILURE 2
#define UHS_NO UHS_FAILURE
#define UHS_MODEL_UNHANDLED UHS_FAILURE
#define UHS_NOT_SUPPORTED 3

/*** Structures ***/

typedef struct BeforeUpgradeOptions {
  int password_exists;
  int keep_calibration_data;
  const char * firmware_name;
  const char * fixed_name;
  const char * dynamic_name;
} BeforeUpgradeOptions, *pBeforeUpgradeOptions;


typedef struct AfterUpgradeOptions {
  int password_exists;
  int keep_calibration_data;
  const char * firmware_name;
  const char * fixed_name;
  const char * dynamic_name;
} AfterUpgradeOptions, *pAfterUpgradeOptions;


typedef struct BeforeImportOptions {
  const char * filepath;
} BeforeImportOptions, *pBeforeImportOptions;


typedef struct AfterImportOptions {
  const char * filepath;
} AfterImportOptions, *pAfterImportOptions;


#endif // _EL_MODIFY_DLL_API_H_

#define EL_DOCKABLE_VERSION 6
#define EL_NUMBER_THEME_GRADIENTS 30
#define EL_LAYOUT_TAB_CONTROL_HEIGHT 19
#define EL_LAYOUT_SHRINK_SIZE 10
#define EL_MINIMUM_CONTOL_WINDOW_WIDTH 60
#define EL_MINIMUM_CONTOL_WINDOW_HEIGHT 20
#define EL_MAIN_WINDOW_MIN_WIDTH 350
#define EL_MAX_LAYOUT_PAGES 50
#define LOG_NUM_TIMESTEPS 1000
#define LOG_MAX_TIMESTAMP 0x7FFFFFFFFFFFFFFFui64

/*** Type definitions ***/
#define DS_SUCCESS 0
#define DS_TRUE 0
#define DS_FAILURE 1
#define DS_FALSE 1
#define DS_REGISTERED 2
#define DS_EXISTS 2
#define DS_INVALID_HOST_CONTEXT 3
#define DS_INVALID_ARGUMENT 4
#define DS_NOT_REGISTERED 5
#define DS_DOES_NOT_EXIST 5
#define DS_NO_MEM 6
#define DS_ACTIVE_CONTROLS 7
#define DS_WINDOW_NOT_REGISTERED 8
#define DS_FILE_NOT_FOUND 9
#define DS_FILE_UPDATE_FAILED 10
#define DS_FILE_INVALID 11
#define DS_NOT_SUPPORTED 12
#define DS_UNSUPPORTED_VERSION 13
#define DS_NO_CONNECTION 14
#define DS_NOT_CONTROL_WINDOW 15
#define DS_INVALID_EXPRESSION 16
#define DS_USER_CANCELED 17
#define DS_INVALID_RESULT 18
#define DS_UNDOCKED 19
#define DS_PINNED 20
#define DS_BUSY 21
#define DS_NO_CHANNELS 22
#define DS_EMPTY_CHANNEL 23
#define DS_INVALID_CHANNEL 24
#define DS_CONTROL_REGISTERED 25
#define DS_CONTROL_NOT_REGISTERED 26
#define DS_NOT_LAYOUT_WINDOW 27
#define DS_MANAGER_REGISTERED 28
#define DS_MANAGER_NOT_REGISTERED 29
#define DS_NOT_IMPLEMENTED 30
#define DS_INVALID_INPUT 31
#define DS_LOGGING 32
#define DS_INVALID_BUFFER 33
#define DS_INVALID_ITEM 34
#define DS_NO_AVAILABLE_CHANNELS 35
#define DS_BAD_STATE 0x50000002
#define DS_ITEM_NOT_FOUND 0x50000005
#define DS_MODIFY_ITEM_NOT_FOUND 0x50000017
typedef UINT DOCKABLE_STATUS;

// System Menu Options/Codes:  The lower 4 bits are not used in the system menu due to a windows bug.
#define EL_SC_SHOW_PROPERTIES 0x10
#define EL_SC_SHOW_CHANNEL_LIST 0x20
#define EL_SC_SHOW_TABLE_CONVERSION 0x30
#define EL_SC_SHOW_XAXIS_CONVERSION 0x40
#define EL_SC_SHOW_YAXIS_CONVERSION 0x50
#define EL_SC_SHOW_NUMBER_FORMAT_OPTIONS 0x60
#define EL_SC_SHOW_COLOR_OPTIONS 0x70
#define EL_SC_DUPLICATE_CONTROL 0x80
#define EL_SC_CHANNEL_PROPERTIES 0x90
#define EL_SC_LOG_CHANNEL 0xA0
#define EL_SC_PLUGIN_START 0x1000
typedef UINT SYSTEM_COMMAND;

// Flags used to select primary, x-axis, or y-axis ELChannelCommonInfo inside a channel.
#define INFOSELECT_NONE 0
#define INFOSELECT_PRIMARY 1
#define INFOSELECT_X_AXIS 2
#define INFOSELECT_Y_AXIS 4
#define INFOSELECT_ALL 0xFFFFFFFF
typedef DWORD INFOSELECT;

#define NUMBERFORMAT_NORMAL 0
#define NUMBERFORMAT_FIXED 1
#define NUMBERFORMAT_SCIENTIFIC 2
#define NUMBERFORMAT_MAX_PRECISION 9
typedef UINT NUMBERFORMAT;

#define CHANNELTYPE_SIMPLE 0x00000001
#define CHANNELTYPE_1DTABLE 0x00000002
#define CHANNELTYPE_2DTABLE 0x00000004
#define CHANNELTYPE_ALL_NONVIRTUAL 0x0000FFFF
#define CHANNELTYPE_VIRTUAL 0x00010000
#define CHANNELTYPE_ALL 0x00FFFFFF
#define CHANNELTYPE_HIDDEN 0x01000000
#define CHANNELTYPE_LOGGED 0x02000000
#define CHANNELTYPE_ALL_WITH_HIDDEN 0xFFFFFFFF
typedef DWORD CHANNELTYPE;

#define CHANNELFLAGS_NONE 0
#define CHANNELFLAGS_VALID 1
#define CHANNELFLAGS_FOLLOW_ECU 2
#define CHANNELFLAGS_INTERPOLATED 4
#define CHANNELFLAGS_LOGGED 8
#define CHANNELFLAGS_CONVERTED 16
typedef DWORD CHANNELFLAGS;

#define ELWINDOWTYPE_NORMAL 0
#define ELWINDOWTYPE_CONTROL 1
#define ELWINDOWTYPE_LAYOUT 2
typedef UINT ELWINDOWTYPE;

#define HOSTSTATE_NONE 0
#define HOSTSTATE_CONNECTION 1
#define HOSTSTATE_PC_LOGGING 2
#define HOSTSTATE_TARGET_LOGGING 4
#define HOSTSTATE_TARGET_STATE 8
#define HOSTSTATE_ALL 0xFFFFFFFF
typedef DWORD HOSTSTATE;

#define MODIFYOPTION_DATA 0
#define MODIFYOPTION_SELECTION 1
#define MODIFYOPTION_FOLLOWECU 2
#define MODIFYOPTION_FORMATTING 3
#define MODIFYOPTION_COLOR 4
#define MODIFYOPTION_VALIDITY 5
#define MODIFYOPTION_LOGGED 6
#define MODIFYOPTION_UNIT 7
#define MODIFYOPTION_LOG_DATA 8
typedef UINT MODIFYOPTION;

#define SELECTFLAGS_NONE 0
#define SELECTFLAGS_CHECKBOXES 1
#define SELECTFLAGS_UNIQUE 2
#define SELECTFLAGS_CSV_ALLOWED 4
#define SELECTFLAGS_CONTAINS_OPTIONS 0x80000000
typedef DWORD SELECTFLAGS;

#define SYSMENUSUPPORT_NONE 0
#define SYSMENUSUPPORT_PROPERTIES 1
#define SYSMENUSUPPORT_SELECT_CHANNEL 2
#define SYSMENUSUPPORT_TABLE_CONVERSION 4
#define SYSMENUSUPPORT_XAXIS_CONVERSION 8
#define SYSMENUSUPPORT_YAXIS_CONVERSION 16
#define SYSMENUSUPPORT_NUMBER_OPTIONS 32
#define SYSMENUSUPPORT_COLOR_OPTIONS 64
#define SYSMENUSUPPORT_DISPLAYS_LOG 0x40000000
#define SYSMENUSUPPORT_DISPLAYS_MULTIPLE 0x80000000
#define SYSMENUSUPPORT_ALL 0xFFFFFFFF
typedef DWORD SYSMENUSUPPORT;

#define HOOKTYPE_NONE 0
#define HOOKTYPE_THEME_RESET 1
#define HOOKTYPE_THEME_APPLY 2
#define HOOKTYPE_THEME 0x00000003
#define HOOKTYPE_LAYOUT_OPEN 4
#define HOOKTYPE_LAYOUT_APPEND 8
#define HOOKTYPE_LAYOUT_CLEAR 16
#define HOOKTYPE_LAYOUT_SAVE 32
#define HOOKTYPE_LAYOUT 0x0000003C
#define HOOKTYPE_VIRTUAL_CLEAR 64
#define HOOKTYPE_VIRTUAL_ADD 128
#define HOOKTYPE_VIRTUAL_MODIFIED 256
#define HOOKTYPE_VIRTUAL 0x000001C0
// Host hook only.
#define HOOKTYPE_WINDOW_CLOSED 512
#define HOOKTYPE_ALL 0xFFFFFFFF
typedef DWORD HOOKTYPE;

#define LAYOUTDELETEOPTION_NONE 0
#define LAYOUTDELETEOPTION_WINDOWS 0x00000001
#define LAYOUTDELETEOPTION_PAGE 0x00000008
#define LAYOUTDELETEOPTION_ALL 0xFFFFFFFF
typedef DWORD LAYOUTDELETEOPTION;

#define LAYOUTCLEAROPTION_NONE 0
#define LAYOUTCLEAROPTION_WINDOWS 0x00000001
#define LAYOUTCLEAROPTION_VIRTUAL 0x00000002
#define LAYOUTCLEAROPTION_THEME 0x00000004
#define LAYOUTCLEAROPTION_PAGES 0x00000009
#define LAYOUTCLEAROPTION_ALL_DATA 0x0000FFFF
#define LAYOUTCLEAROPTION_RESET 0x10000009
#define LAYOUTCLEAROPTION_ALL 0xFFFFFFFF
typedef DWORD LAYOUTCLEAROPTION;

#define LAYOUTSAVEOPTION_NONE 0
#define LAYOUTSAVEOPTION_OVERWRITE 1
#define LAYOUTSAVEOPTION_VIRTUAL 2
#define LAYOUTSAVEOPTION_THEME 4
#define LAYOUTSAVEOPTION_ALL 0xFFFFFFFF
typedef DWORD LAYOUTSAVEOPTION;

#define FORMATTINGOPTION_NONE 0
#define FORMATTINGOPTION_COLOR 1
#define FORMATTINGOPTION_NUMBER 2
#define FORMATTINGOPTION_ALL 0xFFFFFFFF
typedef DWORD FORMATTINGOPTION;

#define CONVERSIONOPERATOR_GENERIC 0
#define CONVERSIONOPERATOR_ADD 1
#define CONVERSIONOPERATOR_SUBTRACT 2
#define CONVERSIONOPERATOR_MULTIPLY 3
#define CONVERSIONOPERATOR_DIVIDE 4
typedef UINT CONVERSIONOPERATOR;

#define VIRTUALCHANNELTYPE_NONE 0
#define VIRTUALCHANNELTYPE_VIRTUAL 1
#define VIRTUALCHANNELTYPE_CONVERSION 2
typedef UINT VIRTUALCHANNELTYPE;

#define DEVICETYPE_NONE 0
#define DEVICETYPE_USB 1
#define DEVICETYPE_SERIAL_1 2
#define DEVICETYPE_SERIAL_2 3
#define DEVICETYPE_CAN 4
#define DEVICETYPE_SIMULATOR 5
#define DEVICETYPE_BLUETOOTH 6
typedef UINT DEVICETYPE;

#define LAYOUTWINDOWPOS_TOP 0
#define LAYOUTWINDOWPOS_LEFT 0
#define LAYOUTWINDOWPOS_BOTTOM 1
#define LAYOUTWINDOWPOS_RIGHT 1
typedef UINT LAYOUTWINDOWPOS;

#define PLUGINSTATUS_SUCCESS DS_SUCCESS
#define PLUGINSTATUS_FAILURE DS_FAILURE
typedef UINT PLUGINSTATUS;

typedef long long LOGTIMESTAMP;

#define CAMCRANKOPTION_HIDDEN 0
#define CAMCRANKOPTION_USER 1
#define CAMCRANKOPTION_AUTO 2
typedef UINT CAMCRANKOPTION;

#define DELETEITEMOPTION_NONE 0
#define DELETEITEMOPTION_INVALIDATE_PARENTS 1
#define DELETEITEMOPTION_GENERATE_EXTERNS 2
#define DELETEITEMOPTION_GENERATE_CONSTANTS 4
#define DELETEITEMOPTION_DO_NOT_DELETE_EXTERNS 8
typedef UINT DELETEITEMOPTION;

#define CANCHANNEL_A 0
#define CANCHANNEL_B 1
typedef UINT CANCHANNEL;

#define TARGETINFO_TIMING_TYPES 0
#define TARGETINFO_EDGE_TRIGGERS 1
#define TARGETINFO_ENGINE_CYCLES 2
#define TARGETINFO_INJECTOR_TYPES 3
#define TARGETINFO_HARNESS_PIN_MODES 4
#define TARGETINFO_CPU_PIN_MODES 5
#define TARGETINFO_TIMER_MODES 6
#define TARGETINFO_UNIT_CONVERSIONS 7
#define TARGETINFO_SYNC_RESPONSES 8
#define TARGETINFO_THERMISTOR_OUTPUT_TYPES 9
#define TARGETINFO_FIXED_TABLE_TYPES 10
#define TARGETINFO_SIMPLE_CAN_FORMAT_TYPES 11
#define TARGETINFO_CAN_ENDIANESS 12
#define TARGETINFO_CAN_ID_FORMATS 13
#define TARGETINFO_MATH_TOKENS 14
#define TARGETINFO_ITEM_TYPES 15
#define TARGETINFO_DATA_TYPES 16
#define TARGETINFO_CAN_PACKET_DATA_TYPES 17
#define TARGETINFO_SERIAL_STREAM_DATA_TYPES 18
#define TARGETINFO_COMMUNICATION_DATA_TYPES 19
#define TARGETINFO_BUS_CHANNELS 20
#define TARGETINFO_BUS_DIRECTIONS 21
#define TARGETINFO_TX_MODES 22
#define TARGETINFO_LATCH_EDGES 23
#define TARGETINFO_LATCH_START_STATES 24
typedef UINT TARGETINFO;

// Used as an index for TARGETINFO_TIMING_TYPES.
#define TIMINGTYPE_SINGLETOOTHCAM 0
#define TIMINGTYPE_HONDA600RR 1
#define TIMINGTYPE_SINGLECAMCRANK1TOOTHMISSING 2
#define TIMINGTYPE_SINGLECAMCRANK1TOOTHMISSING_VVT 3
#define TIMINGTYPE_SINGLECAMCRANK2TOOTHMISSING 4
#define TIMINGTYPE_SINGLECAMCRANK2TOOTHMISSING_VVT 5
#define TIMINGTYPE_HONDACIVIC_5T_CAM_12_1CRANK 6
#define TIMINGTYPE_HONDARSX_5T_4T_CAMS_12_1CRANK_VVT 7
#define TIMINGTYPE_SUBARUWRXSTI_3T_3T_2T_2T_CAMS_36_2_2_2CRANK_VVT 8
#define TIMINGTYPE_1GDSM_2T_CAM_4_CRANK 9
#define TIMINGTYPE_NISSAN_QG18DE_10T_CAM_36_2_CRANK 10
#define TIMINGTYPE_DODGENGC_15T_CAM_36_2_2_CRANK_VVT 11
#define TIMINGTYPE_DODGEVIPER92_95_4T_CAM_20_2_2_2_2_2_CRANK 12
#define TIMINGTYPE_DODGEVIPER96_1T_CAM_20_2_2_2_2_2_CRANK 13
#define TIMINGTYPE_MITSUBISHIEVO8_9_2T_CAM_4_CRANK_VVT 14
#define TIMINGTYPE_GM_LS7_4T_CAM_60_2_CRANK_VVT 15
#define TIMINGTYPE_BMW_S54_7T_6T_CAMS_60_2_CRANK_VVT 16
#define TIMINGTYPE_BMW_S65_7T_6T_CAMS_60_2_CRANK_VVT 17
#define TIMINGTYPE_NISSAN_VQ35_6T_6T_CAMS_36_2_2_2_CRANK_VVT 18
#define TIMINGTYPE_NISSAN_VQ35_6T_6T_3T_3T_CAMS_36_2_2_2_CRANK_VVT 19
#define TIMINGTYPE_NISSAN_VQ37_6T_6T_CAMS_36_2_2_2_CRANK_VVT 20
#define TIMINGTYPE_TOYOTA_2JZGTE_3T_CAM_36_2_CRANK_VVT 21
#define TIMINGTYPE_DODGEVIPER4THGENERATION_5T_CAM_60_2_CRANK 22
#define TIMINGTYPE_HONDAJ35_37_3T_CAM_24_1_1_CRANK 23
#define TIMINGTYPE_SUBARUEZ36_3T_3T_3T_3T_CAMS_36_2_2_2CRANK_VVT 24
#define TIMINGTYPE_HONDAF22C_3T_CAM_12_CRANK_VVT 25
#define TIMINGTYPE_PORSCHE997_4T_4T_CAMS_60_2_CRANK_VVT 26
#define TIMINGTYPE_FORDCOYOTE_7T_7T_7T_7T_CAMS_36_1_CRANK_VVT 27
#define TIMINGTYPE_VOLKSWAGON_4T_CAMS_60_2_CRANK_VVT 28
#define TIMINGTYPE_LAMBORGHINI_4T_4T_4T_4T_CAMS_36_1_1_1_1_CRANK_VVT 29
#define TIMINGTYPE_GM_LFX_4T_4T_4T_4T_CAMS_60_2_CRANK_VVT 30
#define TIMINGTYPE_TOYOTA_2GR_FE_3T_3T_3T_3T_CAMS_36_2_CRANK_VVT 31
#define TIMINGTYPE_YAMAHA_1800_1_CAM_4_1_CRANK 32
#define TIMINGTYPE_NISSAN_RB26DETT_6_CAM_180_CRANK 33
#define TIMINGTYPE_NISSAN_SR20DET_4_CAM_180_CRANK 34
#define TIMINGTYPE_FORD_4_6_3V_5_5_CAM_36_1_CRANK 35
#define TIMINGTYPE_MAZDA_L_MZR_6_CAM_36_2_2_2_CRANK_VVT 36
#define TIMINGTYPE_TOYOTA_3SGE_3T_3T_CAM_36_2_CRANK_VVT 37
#define TIMINGTYPE_CHRYSLER_6_4_HEMI_15T_CAM_60_2_CRANK_VVT 38
#define TIMINGTYPE_GM_ECOTEC_LE5_4T_4T_CAM_60_2_CRANK_VVT 39

// Used as an index for TARGETINFO_EDGE_TRIGGERS.
#define EDGETRIGGER_RISINGEDGE 0
#define EDGETRIGGER_FALLINGEDGE 1
#define EDGETRIGGER_RISINGFALLINGEDGES 2

// Used as an index for TARGETINFO_ENGINE_CYCLES.
#define ENGINECYCLE_TWOSTROKE 0
#define ENGINECYCLE_FOURSTROKE 1

// Used as an index for TARGETINFO_INJECTOR_TYPES.
#define INJECTORTYPE_MULTIPORT 0
#define INJECTORTYPE_GASDIRECTINJECTION 1

// Used as an index for TARGETINFO_HARNESS_PIN_MODES.
#define HARNESSPINMODE_PULLUP_4700_OHM 0
#define HARNESSPINMODE_PULLUP_10000_OHM 1
#define HARNESSPINMODE_PULLUP_2200_OHM 2
#define HARNESSPINMODE_LOWSIDE_2_AMP 3
#define HARNESSPINMODE_LOWSIDE_5_AMP 4
#define HARNESSPINMODE_LOWSIDE_10_AMP 5
#define HARNESSPINMODE_HIGHSIDE_2_AMP 6
#define HARNESSPINMODE_HIGHSIDE_5_AMP 7
#define HARNESSPINMODE_HIGHSIDE_10_AMP 8
#define HARNESSPINMODE_VARIABLE_RELUCTANCE 9
#define HARNESSPINMODE_OPEN_COLLECTOR_200_MAMP 10
#define HARNESSPINMODE_OPEN_COLLECTOR_4_AMP 11
#define HARNESSPINMODE_NO_DRIVE_DIRECT_CONNECT 12
#define HARNESSPINMODE_LOWSIDE_2_8_AMP 13
#define HARNESSPINMODE_LOWSIDE_2_8_WPULLUP 14
#define HARNESSPINMODE_LOWSIDE_6_AMP 15
#define HARNESSPINMODE_LOWSIDE_6_WPULLUP 16
#define HARNESSPINMODE_LOWSIDE_18_AMP 17
#define HARNESSPINMODE_LOWSIDE_18_WPULLUP 18
#define HARNESSPINMODE_INPUT_TRANSISTOR_SWITCH 19
#define HARNESSPINMODE_INPUT_TRANSISTOR_WPULLUP 20
#define HARNESSPINMODE_OPTOCOUPLER 21
#define HARNESSPINMODE_STEPPERMOTORCONTROLLER 22
#define HARNESSPINMODE_LOWSIDE_2_8_WFLYBACK 23
#define HARNESSPINMODE_LOWSIDE_6_WFLYBACK 24
#define HARNESSPINMODE_LOWSIDE_18_WFLYBACK 25
#define HARNESSPINMODE_RS232_RX 26
#define HARNESSPINMODE_RS232_TX 27
#define HARNESSPINMODE_DAC128S085 28

// Used as an index for TARGETINFO_CPU_PIN_MODES.
#define CPUPINMODE_RISING_EDGE_INCREMENT 0
#define CPUPINMODE_FALLING_EDGE_INCREMENT 1
#define CPUPINMODE_BOTH_EDGES_INCREMENT 2
#define CPUPINMODE_RISING_EDGE_DECREMENT 3
#define CPUPINMODE_FALLING_EDGE_DECREMENT 4
#define CPUPINMODE_BOTH_EDGES_DECREMENT 5
#define CPUPINMODE_FREQUENCY_OUTPUT 6
#define CPUPINMODE_FREQUENCY_AND_DUTY_OUTPUT 7
#define CPUPINMODE_FREQUENCY_INPUT 8
#define CPUPINMODE_FREQUENCY_AND_DUTY_INPUT 9
#define CPUPINMODE_GPIO_INPUT 10
#define CPUPINMODE_GPIO_OUTPUT 11
#define CPUPINMODE_TACH_OUTPUT 12
#define CPUPINMODE_STEPPER_MOTOR_PERCENT_CONTROL 13
#define CPUPINMODE_ENGINETIMING_RISING_EDGE 14
#define CPUPINMODE_ENGINETIMING_FALLING_EDGE 15
#define CPUPINMODE_SIGNALDURATIONHIGH 16
#define CPUPINMODE_SIGNALDURATIONLOW 17
#define CPUPINMODE_DAC128S085_OUTPUT 18
#define CPUPINMODE_CAN_TERMINATE_CONTROL_OUTPUT 19

// Used as an index for TARGETINFO_TIMER_MODES.
#define TIMERMODE_ONESHOT 0
#define TIMERMODE_ELAPSEDTIMETRANSITION 1
#define TIMERMODE_SIGNALPRESENTFORTIME 2
#define TIMERMODE_TRANSITIONLINEARRESETINITIAL 3
#define TIMERMODE_TRANSITIONLINEARRESETFINAL 4
#define TIMERMODE_INCREMENTTIME 5

// Used as an index for TARGETINFO_UNIT_CONVERSIONS.
#define UNITCONVERSION_CELSIUSTOFAHRENHEIT 0
#define UNITCONVERSION_CELSIUSTOKELVIN 1
#define UNITCONVERSION_FAHRENHEITTOCELSIUS 2
#define UNITCONVERSION_FAHRENHEITTOKELVIN 3
#define UNITCONVERSION_KELVINTOCELSIUS 4
#define UNITCONVERSION_KELVINTOFAHRENHEIT 5
#define UNITCONVERSION_PSITOKPA 6
#define UNITCONVERSION_KPATOPSI 7

// Used as an index for TARGETINFO_SYNC_RESPONSES.
#define SYNCRESPONSE_STATE_NOT_SYNCED 0
#define SYNCRESPONSE_STATE_SYNCED 1
#define SYNCRESPONSE_STATE_SYNC_ERROR_CRANK_TOOTH_MISSED 2
#define SYNCRESPONSE_STATE_SYNC_ERROR_CRANK_TOOTH_PRESENT 3
#define SYNCRESPONSE_STATE_SYNC_ERROR_PRIMARY_CAM_SIGNATURE 4
#define SYNCRESPONSE_STATE_SYNC_ERROR_SECONDARY_CAM_SIGNATURE 5
#define SYNCRESPONSE_STATE_SYNC_ERROR_SECONDARY0_CAM_SIGNATURE 6
#define SYNCRESPONSE_STATE_SYNC_ERROR_SECONDARY1_CAM_SIGNATURE 7
#define SYNCRESPONSE_STATE_SYNC_ERROR_SECONDARY2_CAM_SIGNATURE 8
#define SYNCRESPONSE_STATE_SYNC_ERROR_SECONDARY3_CAM_SIGNATURE 9
#define SYNCRESPONSE_STATE_SYNC_ERROR_SECONDARY4_CAM_SIGNATURE 10
#define SYNCRESPONSE_STATE_SYNC_ERROR_SECONDARY5_CAM_SIGNATURE 11
#define SYNCRESPONSE_STATE_SYNC_ERROR_SECONDARY6_CAM_SIGNATURE 12
#define SYNCRESPONSE_STATE_SYNC_ERROR_SECONDARY7_CAM_SIGNATURE 13
#define SYNCRESPONSE_STATE_SYNC_ERROR_SECONDARY8_CAM_SIGNATURE 14
#define SYNCRESPONSE_STATE_SYNC_ERROR_SECONDARY9_CAM_SIGNATURE 15
#define SYNCRESPONSE_STATE_SYNC_ERROR_SECONDARY10_CAM_SIGNATURE 16
#define SYNCRESPONSE_STATE_SYNC_ERROR_SECONDARY11_CAM_SIGNATURE 17
#define SYNCRESPONSE_STATE_SYNC_ERROR_SECONDARY12_CAM_SIGNATURE 18
#define SYNCRESPONSE_STATE_SYNC_ERROR_SECONDARY13_CAM_SIGNATURE 19
#define SYNCRESPONSE_STATE_SYNC_ERROR_SECONDARY14_CAM_SIGNATURE 20
#define SYNCRESPONSE_STATE_SYNC_ERROR_SECONDARY15_CAM_SIGNATURE 21
#define SYNCRESPONSE_STATE_SYNC_ERROR_GENERIC0 22
#define SYNCRESPONSE_STATE_SYNC_ERROR_GENERIC1 23
#define SYNCRESPONSE_STATE_SYNC_ERROR_GENERIC2 24
#define SYNCRESPONSE_STATE_SYNC_ERROR_GENERIC3 25
#define SYNCRESPONSE_STATE_SYNC_ERROR_GENERIC4 26
#define SYNCRESPONSE_STATE_SYNC_ERROR_GENERIC5 27
#define SYNCRESPONSE_STATE_SYNC_ERROR_GENERIC6 28
#define SYNCRESPONSE_STATE_SYNC_ERROR_GENERIC7 29
#define SYNCRESPONSE_STATE_SYNC_ERROR_GENERIC8 30
#define SYNCRESPONSE_STATE_SYNC_ERROR_GENERIC9 31

// Used as an index for TARGETINFO_THERMISTOR_OUTPUT_TYPES.
#define THERMISTOROUTPUTTYPE_RESISTANCEOHMS 0
#define THERMISTOROUTPUTTYPE_COOLANTTEMPDEGC 1
#define THERMISTOROUTPUTTYPE_AIRTEMPDEGC 2
#define THERMISTOROUTPUTTYPE_CLT_1GDSM_DEGC 3
#define THERMISTOROUTPUTTYPE_CLT_GM12146312_DEGC 4
#define THERMISTOROUTPUTTYPE_CLT_SUPRA_19937_DEGC 5
#define THERMISTOROUTPUTTYPE_CLT_HONDA1990_01_DEGC 6
#define THERMISTOROUTPUTTYPE_CLT_HONDA2002_06_DEGC 7
#define THERMISTOROUTPUTTYPE_CLT_SUBARU2004_06_DEGC 8
#define THERMISTOROUTPUTTYPE_CLT_EVO89_2GDSM_DEGC 9
#define THERMISTOROUTPUTTYPE_CLT_ACURACLT_DEGC 10
#define THERMISTOROUTPUTTYPE_AIR_GM25036751_DEGC 11
#define THERMISTOROUTPUTTYPE_AIR_HONDAS2000_00_05_DEGC 12
#define THERMISTOROUTPUTTYPE_AIR_HONDA1990_01_DEGC 13
#define THERMISTOROUTPUTTYPE_AIR_SUBARUSTI2004_06_DEGC 14
#define THERMISTOROUTPUTTYPE_AIR_TOYOTAMAF_DEGC 15
#define THERMISTOROUTPUTTYPE_AIR_NISSAN_DEGC 16

// Used as an index for TARGETINFO_FIXED_TABLE_TYPES.
#define FIXEDTABLETYPE_MASSAIRFLOWSENSORLS1 0
#define FIXEDTABLETYPE_MASSAIRFLOWSENSORLS6 1

// Used as an index for TARGETINFO_SIMPLE_CAN_FORMAT_TYPES.
#define SIMPLECANFORMATTYPE_BYTE_FORMAT 0
#define SIMPLECANFORMATTYPE_WORD_FORMAT 1
#define SIMPLECANFORMATTYPE_DWORD_FORMAT 2
#define SIMPLECANFORMATTYPE_FLOAT_FORMAT 3

// Used as an index for TARGETINFO_CAN_ENDIANESS.
#define CANENDIAN_LITTLE_ENDIAN_FORMAT 0
#define CANENDIAN_BIG_ENDIAN_FORMAT 1

// Used as an index for TARGETINFO_CAN_ID_FORMATS.
#define CANIDFORMAT_STANDARD_FORMAT 0
#define CANIDFORMAT_EXTENDED_FORMAT 1

// Used as an index for TARGETINFO_MATH_TOKENS.
#define MATHTOKEN_END 0
#define MATHTOKEN_IMMEDIATE 1
#define MATHTOKEN_PI 2
#define MATHTOKEN_E 3
#define MATHTOKEN_INPUT 4
#define MATHTOKEN_ADD 5
#define MATHTOKEN_SUB 6
#define MATHTOKEN_MUL 7
#define MATHTOKEN_DIV 8
#define MATHTOKEN_MOD 9
#define MATHTOKEN_POW 10
#define MATHTOKEN_NEG 11
#define MATHTOKEN_SQRT 12
#define MATHTOKEN_ABS 13
#define MATHTOKEN_LOG 14
#define MATHTOKEN_LOG10 15
#define MATHTOKEN_SIN 16
#define MATHTOKEN_COS 17
#define MATHTOKEN_TAN 18
#define MATHTOKEN_ASIN 19
#define MATHTOKEN_ACOS 20
#define MATHTOKEN_ATAN 21
#define MATHTOKEN_FLOOR 22
#define MATHTOKEN_CEIL 23
#define MATHTOKEN_MIN 24
#define MATHTOKEN_MAX 25
#define MATHTOKEN_ROUND 26
#define MATHTOKEN_CLAMP 27
#define MATHTOKEN_NOT 28
#define MATHTOKEN_EQUAL 29
#define MATHTOKEN_NE 30
#define MATHTOKEN_GT 31
#define MATHTOKEN_LT 32
#define MATHTOKEN_GTE 33
#define MATHTOKEN_LTE 34
#define MATHTOKEN_AND 35
#define MATHTOKEN_OR 36
#define MATHTOKEN_D2F 37
#define MATHTOKEN_F2D 38
#define MATHTOKEN_LAND 39
#define MATHTOKEN_LOR 40
#define MATHTOKEN_LSHIFTR 41
#define MATHTOKEN_LSHIFTL 42
#define MATHTOKEN_DT 43
#define MATHTOKEN_RAND 44
#define MATHTOKEN_CLAMPL 45
#define MATHTOKEN_CLAMPU 46
#define MATHTOKEN_SELF 47
#define MATHTOKEN_CONDITIONAL 48

// Used as an index for TARGETINFO_ITEM_TYPES.
#define ITEMTYPE_NONE 0
#define ITEMTYPE_ENGINEDESCRIPTOR 1
#define ITEMTYPE_PASSTHROUGH 2
#define ITEMTYPE_ANALOGINPUTCONDITIONING 3
#define ITEMTYPE_PREDEF 4
#define ITEMTYPE_MATH 5
#define ITEMTYPE_IFELSE 6
#define ITEMTYPE_1DTABLE 7
#define ITEMTYPE_2DTABLE 8
#define ITEMTYPE_RUNNINGAVERAGE 9
#define ITEMTYPE_SLOPE 10
#define ITEMTYPE_MULTIPLEX 11
#define ITEMTYPE_MAFFUELREQUIREMENT 12
#define ITEMTYPE_LIMITING 13
#define ITEMTYPE_PROFILER 14
#define ITEMTYPE_EMBEDDEDCODE 15
#define ITEMTYPE_UNITCONVERSION 16
#define ITEMTYPE_THERMISTOR 17
#define ITEMTYPE_PID 18
#define ITEMTYPE_OBDIIPID 19
#define ITEMTYPE_OBDIITID 20
#define ITEMTYPE_SPEEDDENSITY 21
#define ITEMTYPE_TIMER 22
#define ITEMTYPE_HARDWAREIO 23
#define ITEMTYPE_FIXED1DTABLE 24
#define ITEMTYPE_PLANTHARDWAREWRITER 25
#define ITEMTYPE_DIAGNOSTICCODE 26
#define ITEMTYPE_LATCH 27
#define ITEMTYPE_LAMBDASTAGED 28
#define ITEMTYPE_PRIVATE 29
#define ITEMTYPE_CAN_SIMPLETRANSMIT 30
#define ITEMTYPE_CJ125 31
#define ITEMTYPE_EALEVENT 32
#define ITEMTYPE_HIP9011 33
#define ITEMTYPE_PLAYBACK 34
#define ITEMTYPE_COMMUNICATIONSIMPLE 35
#define ITEMTYPE_MODELID 36
#define ITEMTYPE_CANPACKET 37
#define ITEMTYPE_SERIALSTREAM 38
#define ITEMTYPE_ENGINETIMINGGENERATOR 39
#define ITEMTYPE_HWPLACEHOLDER 40
#define ITEMTYPE_CJ125V2 41
#define ITEMTYPE_NMEA2000INTERFACE 42

// Used as an index for TARGETINFO_DATA_TYPES.
#define DATATYPE_FLOAT_2_INT8 0
#define DATATYPE_FLOAT_2_INT16 1
#define DATATYPE_FLOAT_2_INT32 2
#define DATATYPE_FLOAT_2_FLOAT 3
#define DATATYPE_UINT32_2_INT8 4
#define DATATYPE_UINT32_2_INT16 5
#define DATATYPE_UINT32_2_INT32 6
#define DATATYPE_UINT32_2_FLOAT 7
#define DATATYPE_INT32_2_INT8 8
#define DATATYPE_INT32_2_INT16 9
#define DATATYPE_INT32_2_INT32 10
#define DATATYPE_INT32_2_FLOAT 11
#define DATATYPE_UINT16_2_INT32 12
#define DATATYPE_UINT16_2_FLOAT 13
#define DATATYPE_INT16_2_INT32 14
#define DATATYPE_INT16_2_FLOAT 15
#define DATATYPE_UINT8_2_INT32 16
#define DATATYPE_UINT8_2_FLOAT 17
#define DATATYPE_INT8_2_INT32 18
#define DATATYPE_INT8_2_FLOAT 19
#define DATATYPE_FLOAT_2_UINT8 20
#define DATATYPE_FLOAT_2_UINT16 21
#define DATATYPE_FLOAT_2_UINT32 22
#define DATATYPE_FLOAT_2_SIGNMAG8 23
#define DATATYPE_FLOAT_2_SIGNMAG16 24
#define DATATYPE_FLOAT_2_SIGNMAG32 25
#define DATATYPE_SIGNMAG8_2_FLOAT 26
#define DATATYPE_SIGNMAG16_2_FLOAT 27
#define DATATYPE_SIGNMAG32_2_FLOAT 28

// Used as an index for TARGETINFO_CAN_PACKET_DATA_TYPES.
#define CANPACKETDATATYPE_FLOAT_2_INT8 0
#define CANPACKETDATATYPE_FLOAT_2_INT16 1
#define CANPACKETDATATYPE_FLOAT_2_INT32 2
#define CANPACKETDATATYPE_FLOAT_2_FLOAT 3
#define CANPACKETDATATYPE_UINT32_2_INT8 4
#define CANPACKETDATATYPE_UINT32_2_INT16 5
#define CANPACKETDATATYPE_UINT32_2_INT32 6
#define CANPACKETDATATYPE_UINT32_2_FLOAT 7
#define CANPACKETDATATYPE_INT32_2_INT8 8
#define CANPACKETDATATYPE_INT32_2_INT16 9
#define CANPACKETDATATYPE_INT32_2_INT32 10
#define CANPACKETDATATYPE_INT32_2_FLOAT 11
#define CANPACKETDATATYPE_UINT16_2_INT32 12
#define CANPACKETDATATYPE_UINT16_2_FLOAT 13
#define CANPACKETDATATYPE_INT16_2_INT32 14
#define CANPACKETDATATYPE_INT16_2_FLOAT 15
#define CANPACKETDATATYPE_UINT8_2_INT32 16
#define CANPACKETDATATYPE_UINT8_2_FLOAT 17
#define CANPACKETDATATYPE_INT8_2_INT32 18
#define CANPACKETDATATYPE_INT8_2_FLOAT 19
#define CANPACKETDATATYPE_FLOAT_2_UINT8 20
#define CANPACKETDATATYPE_FLOAT_2_UINT16 21
#define CANPACKETDATATYPE_FLOAT_2_UINT32 22
#define CANPACKETDATATYPE_FLOAT_2_SIGNMAG8 23
#define CANPACKETDATATYPE_FLOAT_2_SIGNMAG16 24
#define CANPACKETDATATYPE_FLOAT_2_SIGNMAG32 25
#define CANPACKETDATATYPE_SIGNMAG8_2_FLOAT 26
#define CANPACKETDATATYPE_SIGNMAG16_2_FLOAT 27
#define CANPACKETDATATYPE_SIGNMAG32_2_FLOAT 28

// Used as an index for TARGETINFO_SERIAL_STREAM_DATA_TYPES.
#define SERIALSTREAMDATATYPE_FLOAT_2_INT8 0
#define SERIALSTREAMDATATYPE_FLOAT_2_INT16 1
#define SERIALSTREAMDATATYPE_FLOAT_2_INT32 2
#define SERIALSTREAMDATATYPE_FLOAT_2_FLOAT 3
#define SERIALSTREAMDATATYPE_UINT32_2_INT8 4
#define SERIALSTREAMDATATYPE_UINT32_2_INT16 5
#define SERIALSTREAMDATATYPE_UINT32_2_INT32 6
#define SERIALSTREAMDATATYPE_UINT32_2_FLOAT 7
#define SERIALSTREAMDATATYPE_INT32_2_INT8 8
#define SERIALSTREAMDATATYPE_INT32_2_INT16 9
#define SERIALSTREAMDATATYPE_INT32_2_INT32 10
#define SERIALSTREAMDATATYPE_INT32_2_FLOAT 11
#define SERIALSTREAMDATATYPE_UINT16_2_INT32 12
#define SERIALSTREAMDATATYPE_UINT16_2_FLOAT 13
#define SERIALSTREAMDATATYPE_INT16_2_INT32 14
#define SERIALSTREAMDATATYPE_INT16_2_FLOAT 15
#define SERIALSTREAMDATATYPE_UINT8_2_INT32 16
#define SERIALSTREAMDATATYPE_UINT8_2_FLOAT 17
#define SERIALSTREAMDATATYPE_INT8_2_INT32 18
#define SERIALSTREAMDATATYPE_INT8_2_FLOAT 19
#define SERIALSTREAMDATATYPE_FLOAT_2_UINT8 20
#define SERIALSTREAMDATATYPE_FLOAT_2_UINT16 21
#define SERIALSTREAMDATATYPE_FLOAT_2_UINT32 22
#define SERIALSTREAMDATATYPE_FLOAT_2_SIGNMAG8 23
#define SERIALSTREAMDATATYPE_FLOAT_2_SIGNMAG16 24
#define SERIALSTREAMDATATYPE_FLOAT_2_SIGNMAG32 25
#define SERIALSTREAMDATATYPE_SIGNMAG8_2_FLOAT 26
#define SERIALSTREAMDATATYPE_SIGNMAG16_2_FLOAT 27
#define SERIALSTREAMDATATYPE_SIGNMAG32_2_FLOAT 28

// Used as an index for TARGETINFO_COMMUNICATION_DATA_TYPES.
#define COMMUNICATIONDATATYPE_FLOAT_2_INT8 0
#define COMMUNICATIONDATATYPE_FLOAT_2_INT16 1
#define COMMUNICATIONDATATYPE_FLOAT_2_INT32 2
#define COMMUNICATIONDATATYPE_FLOAT_2_FLOAT 3
#define COMMUNICATIONDATATYPE_UINT32_2_INT8 4
#define COMMUNICATIONDATATYPE_UINT32_2_INT16 5
#define COMMUNICATIONDATATYPE_UINT32_2_INT32 6
#define COMMUNICATIONDATATYPE_UINT32_2_FLOAT 7
#define COMMUNICATIONDATATYPE_INT32_2_INT8 8
#define COMMUNICATIONDATATYPE_INT32_2_INT16 9
#define COMMUNICATIONDATATYPE_INT32_2_INT32 10
#define COMMUNICATIONDATATYPE_INT32_2_FLOAT 11
#define COMMUNICATIONDATATYPE_UINT16_2_INT32 12
#define COMMUNICATIONDATATYPE_UINT16_2_FLOAT 13
#define COMMUNICATIONDATATYPE_INT16_2_INT32 14
#define COMMUNICATIONDATATYPE_INT16_2_FLOAT 15
#define COMMUNICATIONDATATYPE_UINT8_2_INT32 16
#define COMMUNICATIONDATATYPE_UINT8_2_FLOAT 17
#define COMMUNICATIONDATATYPE_INT8_2_INT32 18
#define COMMUNICATIONDATATYPE_INT8_2_FLOAT 19

// Used as an index for TARGETINFO_BUS_CHANNELS.
#define BUSCHANNEL_CHANNELA 0
#define BUSCHANNEL_CHANNELB 1

// Used as an index for TARGETINFO_BUS_DIRECTIONS.
#define BUSDIRECTION_TRANSMIT 0
#define BUSDIRECTION_RECEIVE 1

// Used as an index for TARGETINFO_TX_MODES.
#define TXMODE_PERIODIC 0
#define TXMODE_EVENT 1

// Used as an index for TARGETINFO_LATCH_EDGES.
#define LATCHEDGE_RISING_EDGE 0
#define LATCHEDGE_FALLING_EDGE 1

// Used as an index for TARGETINFO_LATCH_START_STATES.
#define LATCHSTARTSTATE_ZERO 0
#define LATCHSTARTSTATE_NON_ZERO 1

// No filter applied, all items returned.
#define ITEMFILTER_NONE 0
// Do not return those items that are hardware processed.
#define ITEMFILTER_ALL_HW_PROCESSED 1
// Do not return those items of given type.
#define ITEMFILTER_ALL_OF_TYPE 2
// Return only those items that use given channel as input.
#define ITEMFILTER_ALL_BUT_PARENTS_OF_ITEM 3
// Return only those items that are inputs to given channel.
#define ITEMFILTER_ALL_BUT_CHILDREN_OF_ITEM 4
// Return only those items that are hardware processed.
#define ITEMFILTER_ALL_BUT_HW_PROCESSED 5
// Return only those items that are of given type.
#define ITEMFILTER_ALL_BUT_OF_TYPE 6
// Nothing is returned.  Use to test support.
#define ITEMFILTER_ALL 7
// The mask used for the filter.
#define ITEMFILTER_FILTER_MASK 0x000000FF
// The shift required for filter.
#define ITEMFILTER_FILTER_SHIFT 0
// The mask used for item types.  Used for filters ITEMFILTER_ALL_OF_TYPE and ITEMFILTER_ALL_BUT_OF_TYPE.
#define ITEMFILTER_TYPE_MASK 0xFF000000
// The shift required to obtain type.
#define ITEMFILTER_TYPE_SHIFT 24
// The mask used for the channel number.  Used for filters ITEMFILTER_ALL_BUT_PARENTS_OF_ITEM and ITEMFILTER_ALL_BUT_CHILDREN_OF_ITEM.
#define ITEMFILTER_CHANNEL_MASK 0xFFFF0000
// The shift required to obtain the channel.
#define ITEMFILTER_CHANNEL_SHIFT 16
typedef DWORD ITEMFILTER;

#define INPUTTYPE_ITEM 0
#define INPUTTYPE_EXTERN 1
#define INPUTTYPE_CONSTANT 2
#define INPUTTYPE_SELF 3
typedef UINT INPUTTYPE;

#define VS_VALID 0
#define VS_INVALID 1
#define VS_INVALID_THREAD_ID 2
#define VS_INVALID_ITERATION 3
#define VS_INVALID_PRIORITY 4
#define VS_INVALID_INPUTS 5
#define VS_TO_FEW_INPUTS 6
#define VS_TO_MANY_INPUTS 7
#define VS_TO_LARGE 8
#define VS_NAME_EXISTS_ON_TARGET 9
#define VS_NAME_EXISTS_IN_HOST 10
#define VS_INVALID_NAME 11
#define VS_CHANNEL_TO_LARGE 12
#define VS_TARGET_ISSUE 13
#define VS_NOT_SUPPORTED 14
typedef UINT VALIDATESTATUS;

#define ITEMFLAG_PLANT_ITEM 10
#define ITEMFLAG_NO_COMMIT 11
#define ITEMFLAG_IN_RAM_XTRA 12
#define ITEMFLAG_ROM_BASED 13
typedef UINT ITEMFLAG;

#define ITEMMODFLAG_PRIVATE_ITEM 0
#define ITEMMODFLAG_HIDDEN 1
#define ITEMMODFLAG_CLAMP_OUTPUT 2
#define ITEMMODFLAG_USE_TEST_OUTPUT 3
#define ITEMMODFLAG_PASSWORD_PROTECT 4
typedef UINT ITEMMODFLAG;

typedef struct ELWindow ELWindow, *pELWindow;
typedef struct ELControlWindow ELControlWindow, *pELControlWindow;
typedef struct ELLayoutWindow ELLayoutWindow, *pELLayoutWindow;
typedef struct ELChannelGroup ELChannelGroup, *pELChannelGroup;
typedef struct ELControl ELControl, *pELControl;
typedef struct ELGenericBuffer ELGenericBuffer, *pELGenericBuffer;
typedef struct ELPasswordControl ELPasswordControl, *pELPasswordControl;
typedef struct ELCANSniffer ELCANSniffer, *pELCANSniffer;
typedef struct ELGenericInfo ELGenericInfo, *pELGenericInfo;
typedef struct ELCamCrankInfo ELCamCrankInfo, *pELCamCrankInfo;
typedef struct ELTimingType ELTimingType, *pELTimingType;
typedef struct ELCPUPinMode ELCPUPinMode, *pELCPUPinMode;
typedef struct ELMathToken ELMathToken, *pELMathToken;
typedef struct ELItemType ELItemType, *pELItemType;
typedef struct ELEndianess ELEndianess, *pELEndianess;
typedef struct ELBusChannel ELBusChannel, *pELBusChannel;
typedef struct ELBusDirection ELBusDirection, *pELBusDirection;
typedef struct ELBusTxMode ELBusTxMode, *pELBusTxMode;
typedef struct ELLatchEdge ELLatchEdge, *pELLatchEdge;
typedef struct ELLatchStartState ELLatchStartState, *pELLatchStartState;
typedef struct ELDataType ELDataType, *pELDataType;
typedef struct ELGenericInfoList ELGenericInfoList, *pELGenericInfoList;
typedef struct ELModeler ELModeler, *pELModeler;
typedef struct ELTarget ELTarget, *pELTarget;
typedef struct ELConfiguration ELConfiguration, *pELConfiguration;
typedef struct ELLayoutManager ELLayoutManager, *pELLayoutManager;
typedef struct ELHook ELHook, *pELHook;
typedef struct ELLayout ELLayout, *pELLayout;
typedef struct ELDialogs ELDialogs, *pELDialogs;
typedef struct ELUnitConverter ELUnitConverter, *pELUnitConverter;
typedef struct ELDevice ELDevice, *pELDevice;
typedef struct ELDeviceList ELDeviceList, *pELDeviceList;
typedef struct ELRawLogData ELRawLogData, *pELRawLogData;
typedef struct ELHost ELHost, *pELHost;
typedef struct ELBusOverride ELBusOverride, *pELBusOverride;
typedef struct ELLatch ELLatch, *pELLatch;
typedef struct ELExtern ELExtern, *pELExtern;
typedef struct ELExternList ELExternList, *pELExternList;
typedef struct ELItemInput ELItemInput, *pELItemInput;
typedef struct ELItemInputs ELItemInputs, *pELItemInputs;
typedef struct ELItemThreadControl ELItemThreadControl, *pELItemThreadControl;
typedef struct ELItemHeader ELItemHeader, *pELItemHeader;
typedef struct ELItem ELItem, *pELItem;
typedef struct ELItemList ELItemList, *pELItemList;
typedef struct ELNoOperationItem ELNoOperationItem, *pELNoOperationItem;
typedef struct ELCANPacketEntry ELCANPacketEntry, *pELCANPacketEntry;
typedef struct ELCANPacketEntries ELCANPacketEntries, *pELCANPacketEntries;
typedef struct ELCANPacket ELCANPacket, *pELCANPacket;
typedef struct ELCANPacketItem ELCANPacketItem, *pELCANPacketItem;

/*** Structures ***/

// RECT should be defined in windows.h...
# if EL_REQUIRED_RECT_STRUCT
typedef struct RECT {
  long left;
  long top;
  long right;
  long bottom;
} RECT, *pRECT;
# endif // EL_REQUIRED_RECT_STRUCT


// MSG should be defined in windows.h...
# if EL_REQUIRED_MSG_STRUCT
typedef struct MSG {
  HWND hwnd;
  UINT message;
  UINT wParam;
  long lParam;
  DWORD time;
  POINT pt;
} MSG, *pMSG;
# endif // EL_REQUIRED_MSG_STRUCT


typedef struct ELString {
  // In bytes.
  const UINT capacity;
  // In bytes.
  UINT size;
  // In characters.
  UINT length;
  union {
    char * str;
    wchar_t * wstr;
  };
} ELString, *pELString;


typedef struct ELStringArray {
  const BOOL owns_elements;
  const UINT capacity;
  UINT count;
  pELString * elements;
} ELStringArray, *pELStringArray;


typedef struct ELArray {
  const UINT capacity;
  UINT count;
  UINT * elements;
} ELArray, *pELArray;


typedef struct ELLogInfo {
  const LOGTIMESTAMP max_length;
  LOGTIMESTAMP length;
  LOGTIMESTAMP display_start_time;
  LOGTIMESTAMP display_end_time;
  LOGTIMESTAMP display_cursor;
} ELLogInfo, *pELLogInfo;


typedef struct ELColorTriple {
  COLORREF low;
  COLORREF mid;
  COLORREF high;
} ELColorTriple, *pELColorTriple;


typedef struct ELThemeColors {
  COLORREF background_color;
  COLORREF text_color_primary;
  COLORREF text_light_color;
  COLORREF text_dark_color;
  COLORREF grid_lines_color;
  COLORREF indicator_color;
  COLORREF modified_color;
  ELColorTriple gradient_colors[EL_NUMBER_THEME_GRADIENTS];
} ELThemeColors, *pELThemeColors;


typedef struct ELColorGradient {
  float low_start;
  float low_end;
  float high_start;
  float high_end;
} ELColorGradient, *pELColorGradient;


typedef struct ELNumberFormat {
  NUMBERFORMAT format;
  UINT precision;
  BOOL show_sign;
} ELNumberFormat, *pELNumberFormat;


typedef struct ELCellInfo {
  UINT size;
  UINT max_size;
  float * data;
  float * base;
} ELCellInfo, *pELCellInfo;


typedef struct ELChannelFormattingInfo {
  ELNumberFormat number_format;
  ELColorGradient color_gradient;
  UINT color_triple_index;
} ELChannelFormattingInfo, *pELChannelFormattingInfo;


typedef struct ELChannelCommonInfo {
  WORD channel;
  WORD dummy;
  UINT base_unit;
  UINT unit;
  ELString name;
  const float * value;
  ELCellInfo cells;
  ELChannelFormattingInfo info;
} ELChannelCommonInfo, *pELChannelCommonInfo;


typedef struct ELChannelLogData {
  const UINT size;
  const float * min_array;
  const float * max_array;
} ELChannelLogData, *pELChannelLogData;


typedef struct ELChannelInfo {
  CHANNELTYPE type;
  CHANNELFLAGS flags;
  ELChannelCommonInfo primary;
  ELChannelLogData log;
  float initial_value;
  float base_initial_value;
  RECT selection;
  ELChannelCommonInfo x_axis;
  ELChannelCommonInfo y_axis;
} ELChannelInfo, *pELChannelInfo;


// This will hold pointers to actual log data.
typedef struct ELRawLogConstData {
  // Number of samples. [0, count) is valid for data and timestamp array.
  DWORD count;
  const float * data;
  const LOGTIMESTAMP * timestamps;
} ELRawLogConstData, *pELRawLogConstData;


typedef struct EL3DData {
  LPDIRECT3D9 d3d;
  LPDIRECT3DDEVICE9 device;
  D3DPRESENT_PARAMETERS pp;
  D3DCAPS9 caps;
  LPD3DXMESH font_char_meshes[256];
  ABCFLOAT font_char_ABC_data[256];
} EL3DData, *pEL3DData;


typedef struct ELHostInfo {
  BOOL connected;
  BOOL running;
  BOOL logging;
  BOOL target_logging;
  ELString initial_directory;
  ELString executable_directory;
  ELString documents_directory;
} ELHostInfo, *pELHostInfo;


typedef struct ELVersions {
  DWORD plugin;
  DWORD dockable;
  DWORD target;
  DWORD full_target;
  DWORD configuration;
  DWORD layout;
  DWORD generic_table;
  DWORD dialogs;
  DWORD host;
  DWORD unit_converter;
  DWORD device;
  DWORD device_list;
} ELVersions, *pELVersions;


typedef struct ELChannelSelectInfo {
  CHANNELTYPE types_allowed;
  UINT min_allowed;
  UINT max_allowed;
  SELECTFLAGS flags;
} ELChannelSelectInfo, *pELChannelSelectInfo;


typedef struct ELTargetVersion {
  DWORD major;
  DWORD minor;
} ELTargetVersion, *pELTargetVersion;

#ifndef EL_GENERIC_FUNCTION_VERSION
# define EL_GENERIC_FUNCTION_VERSION 3
#endif

typedef struct ELGenericFunctionTable {
  DWORD version;
  UINT (*AllocateString)(const char * value, pELString * out_string);
  UINT (*CopyString)(pELString dest, const pELString src);
  UINT (*SetString)(pELString dest, const char * value, UINT value_length);
  int (*CompareStrings)(const pELString str1, const pELString str2);
  void (*FreeString)(pELString * string);
  UINT (*AllocateStringArray)(UINT count, BOOL own, pELStringArray * out_array);
  UINT (*ResizeStringArray)(UINT count, pELStringArray * string_array);
  void (*FreeStringArray)(pELStringArray * string_array);
  UINT (*AllocateCellInfo)(UINT cell_count, pELCellInfo * cells);
  UINT (*CopyCellInfo)(pELCellInfo dest, const pELCellInfo src);
  UINT (*SetCellInfo)(pELCellInfo cells, const float * float_array, UINT array_length);
  void (*FreeCellInfo)(pELCellInfo * cells);
  UINT (*Print)(pELNumberFormat formatting, float value, pELString * out_string);
  UINT (*Scan)(const char * string, float * out_value);
  UINT (*ColorAt)(const pELColorGradient gradient, const pELColorTriple colors, float value, COLORREF * out_color);
#if EL_GENERIC_FUNCTION_VERSION >= 2
  UINT (*AllocateArray)(UINT count, pELArray * out_array);
#endif
#if EL_GENERIC_FUNCTION_VERSION >= 2
  UINT (*ResizeArray)(UINT count, pELArray * out_array);
#endif
#if EL_GENERIC_FUNCTION_VERSION >= 2
  void (*FreeArray)(pELArray * arr);
#endif
#if EL_GENERIC_FUNCTION_VERSION >= 3
  UINT (*RegisterHook)(HOOKTYPE for_type, pELHook hook);
#endif
#if EL_GENERIC_FUNCTION_VERSION >= 3
  UINT (*UnregisterHook)(HOOKTYPE from_type, pELHook hook);
#endif
} ELGenericFunctionTable, *pELGenericFunctionTable;


typedef struct ELControlInfo {
  const char * name;
  pELControlWindow (*Create)(void);
} ELControlInfo, *pELControlInfo;


typedef struct ELWindowInfo {
  const char * name;
  pELWindow (*Create)(HWND hwnd);
} ELWindowInfo, *pELWindowInfo;


typedef struct ELLayoutInfo {
  const char * name;
  pELLayoutWindow (*Create)(HWND hwnd, LAYOUTWINDOWPOS pos);
} ELLayoutInfo, *pELLayoutInfo;

typedef pELControlWindow (*ControlWindowCreateFunction)(void);
typedef pELWindow (*WindowCreateFunction)(HWND);
typedef pELLayoutWindow (*LayoutWindowCreateFunction)(HWND, LAYOUTWINDOWPOS);
/*** Interfaces ***/
# if !defined(__cplusplus) || defined(CINTERFACE)
#  define FUNC(p) (p)->lpVtbl
#  define PARAM(p) p
#  define PARAM_(p) p,
# else
#  define FUNC(p) (p)
#  define PARAM(p)
#  define PARAM_(p)
# endif

# undef INTERFACE
# define INTERFACE ELWindow
DECLARE_INTERFACE(ELWindow) {
  STDMETHOD_(pELHost, Host)(THIS) PURE;
  STDMETHOD_(ELWINDOWTYPE, Type)(THIS) PURE;
  STDMETHOD_(void, Destroy)(THIS) PURE;
  STDMETHOD_(HWND, GetHWND)(THIS) PURE;
  STDMETHOD_(BOOL, CanResize)(THIS_ RECT * new_rect) PURE;
  STDMETHOD_(BOOL, IsSavable)(THIS) PURE;
  STDMETHOD_(void, BeginModal)(THIS) PURE;
  STDMETHOD_(void, EndModal)(THIS) PURE;
  STDMETHOD_(const char *, TypeName)(THIS) PURE;
  STDMETHOD_(void, LoadSettingsFromString)(THIS_ const char * settings) PURE;
  STDMETHOD_(pELString, SaveSettingsToString)(THIS) PURE;
  STDMETHOD_(void, GetStrings)(THIS_ pELStringArray * strings, BOOL * release) PURE;
  STDMETHOD_(void, SetStrings)(THIS_ pELStringArray strings) PURE;
  STDMETHOD_(void, ThemeChanged)(THIS_ const pELThemeColors theme) PURE;
  STDMETHOD_(void, HostStateChanged)(THIS_ const pELHostInfo host, HOSTSTATE states_changed) PURE;
  STDMETHOD_(void, ApplicationOptionsChanged)(THIS) PURE;
}; // ELWindow
typedef ELWindow *pELWindow;

# if defined(__cplusplus)
template<typename _Class>
struct my_window : public ELWindow {
  my_window() { }
  STDMETHODIMP_(pELHost) Host() { return _data->Host(); }
  STDMETHODIMP_(ELWINDOWTYPE) Type() { return ELWINDOWTYPE_NORMAL; }
  STDMETHODIMP_(void) Destroy() { _data->Destroy(); }
  STDMETHODIMP_(HWND) GetHWND() { return _data->GetHWND(); }
  STDMETHODIMP_(BOOL) CanResize( RECT * new_rect) { return _data->CanResize(new_rect); }
  STDMETHODIMP_(BOOL) IsSavable() { return _data->IsSavable(); }
  STDMETHODIMP_(void) BeginModal() { _data->BeginModal(); }
  STDMETHODIMP_(void) EndModal() { _data->EndModal(); }
  STDMETHODIMP_(const char *) TypeName() { return _data->TypeName(); }
  STDMETHODIMP_(void) LoadSettingsFromString( const char * settings) { _data->LoadSettingsFromString(settings); }
  STDMETHODIMP_(pELString) SaveSettingsToString() { return _data->SaveSettingsToString(); }
  STDMETHODIMP_(void) GetStrings( pELStringArray * strings, BOOL * release) { _data->GetStrings(strings, release); }
  STDMETHODIMP_(void) SetStrings( pELStringArray strings) { _data->SetStrings(strings); }
  STDMETHODIMP_(void) ThemeChanged( const pELThemeColors theme) { _data->ThemeChanged(theme); }
  STDMETHODIMP_(void) HostStateChanged( const pELHostInfo host, HOSTSTATE states_changed) { _data->HostStateChanged(host, states_changed); }
  STDMETHODIMP_(void) ApplicationOptionsChanged() { _data->ApplicationOptionsChanged(); }
  _Class *_data;
}; // my_window
# endif

# ifndef EL_IGNORE_HELPER_MACROS
#  define ELWindow_Host(p) FUNC(p)->Host(PARAM(p))
#  define ELWindow_Type(p) FUNC(p)->Type(PARAM(p))
#  define ELWindow_Destroy(p) FUNC(p)->Destroy(PARAM(p))
#  define ELWindow_GetHWND(p) FUNC(p)->GetHWND(PARAM(p))
#  define ELWindow_CanResize(p, a) FUNC(p)->CanResize(PARAM_(p) a)
#  define ELWindow_IsSavable(p) FUNC(p)->IsSavable(PARAM(p))
#  define ELWindow_BeginModal(p) FUNC(p)->BeginModal(PARAM(p))
#  define ELWindow_EndModal(p) FUNC(p)->EndModal(PARAM(p))
#  define ELWindow_TypeName(p) FUNC(p)->TypeName(PARAM(p))
#  define ELWindow_LoadSettingsFromString(p, a) FUNC(p)->LoadSettingsFromString(PARAM_(p) a)
#  define ELWindow_SaveSettingsToString(p) FUNC(p)->SaveSettingsToString(PARAM(p))
#  define ELWindow_GetStrings(p, a, b) FUNC(p)->GetStrings(PARAM_(p) a, b)
#  define ELWindow_SetStrings(p, a) FUNC(p)->SetStrings(PARAM_(p) a)
#  define ELWindow_ThemeChanged(p, a) FUNC(p)->ThemeChanged(PARAM_(p) a)
#  define ELWindow_HostStateChanged(p, a, b) FUNC(p)->HostStateChanged(PARAM_(p) a, b)
#  define ELWindow_ApplicationOptionsChanged(p) FUNC(p)->ApplicationOptionsChanged(PARAM(p))
# endif

# undef INTERFACE
# define INTERFACE ELControlWindow
DECLARE_INTERFACE_(ELControlWindow, ELWindow) {
  STDMETHOD_(pELHost, Host)(THIS) PURE;
  STDMETHOD_(ELWINDOWTYPE, Type)(THIS) PURE;
  STDMETHOD_(void, Destroy)(THIS) PURE;
  STDMETHOD_(HWND, GetHWND)(THIS) PURE;
  STDMETHOD_(BOOL, CanResize)(THIS_ RECT * new_rect) PURE;
  STDMETHOD_(BOOL, IsSavable)(THIS) PURE;
  STDMETHOD_(void, BeginModal)(THIS) PURE;
  STDMETHOD_(void, EndModal)(THIS) PURE;
  STDMETHOD_(const char *, TypeName)(THIS) PURE;
  STDMETHOD_(void, LoadSettingsFromString)(THIS_ const char * settings) PURE;
  STDMETHOD_(pELString, SaveSettingsToString)(THIS) PURE;
  STDMETHOD_(void, GetStrings)(THIS_ pELStringArray * strings, BOOL * release) PURE;
  STDMETHOD_(void, SetStrings)(THIS_ pELStringArray strings) PURE;
  STDMETHOD_(void, ThemeChanged)(THIS_ const pELThemeColors theme) PURE;
  STDMETHOD_(void, HostStateChanged)(THIS_ const pELHostInfo host, HOSTSTATE states_changed) PURE;
  STDMETHOD_(void, ApplicationOptionsChanged)(THIS) PURE;
  STDMETHOD_(pELControl, Control)(THIS) PURE;
  STDMETHOD_(void, DestroyHWND)(THIS) PURE;
  STDMETHOD_(HWND, CreateHWND)(THIS_ HWND parent) PURE;
}; // ELControlWindow
typedef ELControlWindow *pELControlWindow;

# if defined(__cplusplus)
template<typename _Class>
struct my_control_window : public ELControlWindow {
  my_control_window() { }
  STDMETHODIMP_(pELHost) Host() { return _data->Host(); }
  STDMETHODIMP_(ELWINDOWTYPE) Type() { return ELWINDOWTYPE_CONTROL; }
  STDMETHODIMP_(void) Destroy() { _data->Destroy(); }
  STDMETHODIMP_(HWND) GetHWND() { return _data->GetHWND(); }
  STDMETHODIMP_(BOOL) CanResize( RECT * new_rect) { return _data->CanResize(new_rect); }
  STDMETHODIMP_(BOOL) IsSavable() { return TRUE; }
  STDMETHODIMP_(void) BeginModal() { _data->BeginModal(); }
  STDMETHODIMP_(void) EndModal() { _data->EndModal(); }
  STDMETHODIMP_(const char *) TypeName() { return _data->TypeName(); }
  STDMETHODIMP_(void) LoadSettingsFromString( const char * settings) { _data->LoadSettingsFromString(settings); }
  STDMETHODIMP_(pELString) SaveSettingsToString() { return _data->SaveSettingsToString(); }
  STDMETHODIMP_(void) GetStrings( pELStringArray * strings, BOOL * release) { _data->GetStrings(strings, release); }
  STDMETHODIMP_(void) SetStrings( pELStringArray strings) { _data->SetStrings(strings); }
  STDMETHODIMP_(void) ThemeChanged( const pELThemeColors theme) { _data->ThemeChanged(theme); }
  STDMETHODIMP_(void) HostStateChanged( const pELHostInfo host, HOSTSTATE states_changed) { _data->HostStateChanged(host, states_changed); }
  STDMETHODIMP_(void) ApplicationOptionsChanged() { _data->ApplicationOptionsChanged(); }
  STDMETHODIMP_(pELControl) Control() { return _data->Control(); }
  STDMETHODIMP_(void) DestroyHWND() { _data->DestroyHWND(); }
  STDMETHODIMP_(HWND) CreateHWND( HWND parent) { return _data->CreateHWND(parent); }
  _Class *_data;
}; // my_control_window
# endif

# ifndef EL_IGNORE_HELPER_MACROS
#  define ELControlWindow_Control(p) FUNC(p)->Control(PARAM(p))
#  define ELControlWindow_DestroyHWND(p) FUNC(p)->DestroyHWND(PARAM(p))
#  define ELControlWindow_CreateHWND(p, a) FUNC(p)->CreateHWND(PARAM_(p) a)
# endif

# undef INTERFACE
# define INTERFACE ELLayoutWindow
DECLARE_INTERFACE_(ELLayoutWindow, ELWindow) {
  STDMETHOD_(pELHost, Host)(THIS) PURE;
  STDMETHOD_(ELWINDOWTYPE, Type)(THIS) PURE;
  STDMETHOD_(void, Destroy)(THIS) PURE;
  STDMETHOD_(HWND, GetHWND)(THIS) PURE;
  STDMETHOD_(BOOL, CanResize)(THIS_ RECT * new_rect) PURE;
  STDMETHOD_(BOOL, IsSavable)(THIS) PURE;
  STDMETHOD_(void, BeginModal)(THIS) PURE;
  STDMETHOD_(void, EndModal)(THIS) PURE;
  STDMETHOD_(const char *, TypeName)(THIS) PURE;
  STDMETHOD_(void, LoadSettingsFromString)(THIS_ const char * settings) PURE;
  STDMETHOD_(pELString, SaveSettingsToString)(THIS) PURE;
  STDMETHOD_(void, GetStrings)(THIS_ pELStringArray * strings, BOOL * release) PURE;
  STDMETHOD_(void, SetStrings)(THIS_ pELStringArray strings) PURE;
  STDMETHOD_(void, ThemeChanged)(THIS_ const pELThemeColors theme) PURE;
  STDMETHOD_(void, HostStateChanged)(THIS_ const pELHostInfo host, HOSTSTATE states_changed) PURE;
  STDMETHOD_(void, ApplicationOptionsChanged)(THIS) PURE;
  STDMETHOD_(pELLayoutManager, LayoutManager)(THIS) PURE;
  STDMETHOD_(void, Shrink)(THIS) PURE;
  STDMETHOD_(void, Expand)(THIS) PURE;
}; // ELLayoutWindow
typedef ELLayoutWindow *pELLayoutWindow;

# if defined(__cplusplus)
template<typename _Class>
struct my_layout_window : public ELLayoutWindow {
  my_layout_window() { }
  STDMETHODIMP_(pELHost) Host() { return _data->Host(); }
  STDMETHODIMP_(ELWINDOWTYPE) Type() { return ELWINDOWTYPE_LAYOUT; }
  STDMETHODIMP_(void) Destroy() { _data->Destroy(); }
  STDMETHODIMP_(HWND) GetHWND() { return _data->GetHWND(); }
  STDMETHODIMP_(BOOL) CanResize( RECT * new_rect) { return TRUE; }
  STDMETHODIMP_(BOOL) IsSavable() { return FALSE; }
  STDMETHODIMP_(void) BeginModal() { /* Do nothing */ }
  STDMETHODIMP_(void) EndModal() { /* Do nothing */ }
  STDMETHODIMP_(const char *) TypeName() { return "layout_window"; }
  STDMETHODIMP_(void) LoadSettingsFromString( const char * settings) { /* Do nothing */ }
  STDMETHODIMP_(pELString) SaveSettingsToString() { return NULL; }
  STDMETHODIMP_(void) GetStrings( pELStringArray * strings, BOOL * release) { *strings = NULL; *release = FALSE; }
  STDMETHODIMP_(void) SetStrings( pELStringArray strings) { /* Do nothing */ }
  STDMETHODIMP_(void) ThemeChanged( const pELThemeColors theme) { _data->ThemeChanged(theme); }
  STDMETHODIMP_(void) HostStateChanged( const pELHostInfo host, HOSTSTATE states_changed) { _data->HostStateChanged(host, states_changed); }
  STDMETHODIMP_(void) ApplicationOptionsChanged() { _data->ApplicationOptionsChanged(); }
  STDMETHODIMP_(pELLayoutManager) LayoutManager() { return _data->LayoutManager(); }
  STDMETHODIMP_(void) Shrink() { _data->Shrink(); }
  STDMETHODIMP_(void) Expand() { _data->Expand(); }
  _Class *_data;
}; // my_layout_window
# endif

# ifndef EL_IGNORE_HELPER_MACROS
#  define ELLayoutWindow_LayoutManager(p) FUNC(p)->LayoutManager(PARAM(p))
#  define ELLayoutWindow_Shrink(p) FUNC(p)->Shrink(PARAM(p))
#  define ELLayoutWindow_Expand(p) FUNC(p)->Expand(PARAM(p))
# endif

# undef INTERFACE
# define INTERFACE ELChannelGroup
DECLARE_INTERFACE(ELChannelGroup) {
  STDMETHOD_(void, Update)(THIS) PURE;
  STDMETHOD_(UINT, AddChannel)(THIS_ pELChannelInfo channel) PURE;
  STDMETHOD_(void, RemoveChannel)(THIS_ pELChannelInfo channel) PURE;
  STDMETHOD_(UINT, ChannelCount)(THIS) PURE;
  STDMETHOD_(pELChannelInfo, Channel)(THIS_ UINT index) PURE;
  STDMETHOD_(BOOL, ChannelIndex)(THIS_ pELChannelInfo channel, UINT * out_index) PURE;
  STDMETHOD_(void, ChannelsChanged)(THIS) PURE;
  STDMETHOD_(void, ChannelModified)(THIS_ MODIFYOPTION option, pELChannelInfo channel, INFOSELECT which) PURE;
  STDMETHOD_(const pELChannelSelectInfo, Info)(THIS) PURE;
}; // ELChannelGroup
typedef ELChannelGroup *pELChannelGroup;

# if defined(__cplusplus)
template<typename _Class>
struct my_channel_group : public ELChannelGroup {
  my_channel_group() { }
  STDMETHODIMP_(void) Update() { _data->Update(); }
  STDMETHODIMP_(UINT) AddChannel( pELChannelInfo channel) { return _data->AddChannel(channel); }
  STDMETHODIMP_(void) RemoveChannel( pELChannelInfo channel) { _data->RemoveChannel(channel); }
  STDMETHODIMP_(UINT) ChannelCount() { return _data->ChannelCount(); }
  STDMETHODIMP_(pELChannelInfo) Channel( UINT index) { return _data->Channel(index); }
  STDMETHODIMP_(BOOL) ChannelIndex( pELChannelInfo channel, UINT * out_index) { return _data->ChannelIndex(channel, out_index); }
  STDMETHODIMP_(void) ChannelsChanged() { _data->ChannelsChanged(); }
  STDMETHODIMP_(void) ChannelModified( MODIFYOPTION option, pELChannelInfo channel, INFOSELECT which) { _data->ChannelModified(option, channel, which); }
  STDMETHODIMP_(const pELChannelSelectInfo) Info() { return _data->Info(); }
  _Class *_data;
}; // my_channel_group
# endif

# ifndef EL_IGNORE_HELPER_MACROS
#  define ELChannelGroup_Update(p) FUNC(p)->Update(PARAM(p))
#  define ELChannelGroup_AddChannel(p, a) FUNC(p)->AddChannel(PARAM_(p) a)
#  define ELChannelGroup_RemoveChannel(p, a) FUNC(p)->RemoveChannel(PARAM_(p) a)
#  define ELChannelGroup_ChannelCount(p) FUNC(p)->ChannelCount(PARAM(p))
#  define ELChannelGroup_Channel(p, a) FUNC(p)->Channel(PARAM_(p) a)
#  define ELChannelGroup_ChannelIndex(p, a, b) FUNC(p)->ChannelIndex(PARAM_(p) a, b)
#  define ELChannelGroup_ChannelsChanged(p) FUNC(p)->ChannelsChanged(PARAM(p))
#  define ELChannelGroup_ChannelModified(p, a, b, c) FUNC(p)->ChannelModified(PARAM_(p) a, b, c)
#  define ELChannelGroup_Info(p) FUNC(p)->Info(PARAM(p))
# endif

# undef INTERFACE
# define INTERFACE ELControl
DECLARE_INTERFACE_(ELControl, ELChannelGroup) {
  STDMETHOD_(void, Update)(THIS) PURE;
  STDMETHOD_(UINT, AddChannel)(THIS_ pELChannelInfo channel) PURE;
  STDMETHOD_(void, RemoveChannel)(THIS_ pELChannelInfo channel) PURE;
  STDMETHOD_(UINT, ChannelCount)(THIS) PURE;
  STDMETHOD_(pELChannelInfo, Channel)(THIS_ UINT index) PURE;
  STDMETHOD_(BOOL, ChannelIndex)(THIS_ pELChannelInfo channel, UINT * out_index) PURE;
  STDMETHOD_(void, ChannelsChanged)(THIS) PURE;
  STDMETHOD_(void, ChannelModified)(THIS_ MODIFYOPTION option, pELChannelInfo channel, INFOSELECT which) PURE;
  STDMETHOD_(const pELChannelSelectInfo, Info)(THIS) PURE;
  STDMETHOD_(pELWindow, Window)(THIS) PURE;
  STDMETHOD_(void, Render)(THIS) PURE;
  STDMETHOD_(SYSMENUSUPPORT, SysMenuSupport)(THIS) PURE;
  STDMETHOD_(pELChannelInfo, ActiveChannel)(THIS) PURE;
  STDMETHOD_(void, UserMathExpression)(THIS_ const char * expression) PURE;
  STDMETHOD_(BOOL, ShowSelectChannelDlg)(THIS) PURE;
  STDMETHOD_(BOOL, ShowPropertiesDlg)(THIS) PURE;
// GetChannelOptions
//   Only called by the host if SELECTFLAGS_CONTAINS_OPTIONS is set.
  STDMETHOD_(void, GetChannelOptions)(THIS_ pELChannelInfo channel, pELStringArray * options, BOOL * release) PURE;
// SetChannelOptions
//   Only called by the host if SELECTFLAGS_CONTAINS_OPTIONS is set.
  STDMETHOD_(void, SetChannelOptions)(THIS_ pELChannelInfo channel, pELStringArray options) PURE;
}; // ELControl
typedef ELControl *pELControl;

# if defined(__cplusplus)
template<typename _Class>
struct my_control : public ELControl {
  my_control() { }
  STDMETHODIMP_(void) Update() { _data->Update(); }
  STDMETHODIMP_(UINT) AddChannel( pELChannelInfo channel) { return _data->AddChannel(channel); }
  STDMETHODIMP_(void) RemoveChannel( pELChannelInfo channel) { _data->RemoveChannel(channel); }
  STDMETHODIMP_(UINT) ChannelCount() { return _data->ChannelCount(); }
  STDMETHODIMP_(pELChannelInfo) Channel( UINT index) { return _data->Channel(index); }
  STDMETHODIMP_(BOOL) ChannelIndex( pELChannelInfo channel, UINT * out_index) { return _data->ChannelIndex(channel, out_index); }
  STDMETHODIMP_(void) ChannelsChanged() { _data->ChannelsChanged(); }
  STDMETHODIMP_(void) ChannelModified( MODIFYOPTION option, pELChannelInfo channel, INFOSELECT which) { _data->ChannelModified(option, channel, which); }
  STDMETHODIMP_(const pELChannelSelectInfo) Info() { return _data->Info(); }
  STDMETHODIMP_(pELWindow) Window() { return _data->Window(); }
  STDMETHODIMP_(void) Render() { _data->Render(); }
  STDMETHODIMP_(SYSMENUSUPPORT) SysMenuSupport() { return _data->SysMenuSupport(); }
  STDMETHODIMP_(pELChannelInfo) ActiveChannel() { return _data->ActiveChannel(); }
  STDMETHODIMP_(void) UserMathExpression( const char * expression) { _data->UserMathExpression(expression); }
  STDMETHODIMP_(BOOL) ShowSelectChannelDlg() { return _data->ShowSelectChannelDlg(); }
  STDMETHODIMP_(BOOL) ShowPropertiesDlg() { return _data->ShowPropertiesDlg(); }
  STDMETHODIMP_(void) GetChannelOptions( pELChannelInfo channel, pELStringArray * options, BOOL * release) { _data->GetChannelOptions(channel, options, release); }
  STDMETHODIMP_(void) SetChannelOptions( pELChannelInfo channel, pELStringArray options) { _data->SetChannelOptions(channel, options); }
  _Class *_data;
}; // my_control
# endif

# ifndef EL_IGNORE_HELPER_MACROS
#  define ELControl_Window(p) FUNC(p)->Window(PARAM(p))
#  define ELControl_Render(p) FUNC(p)->Render(PARAM(p))
#  define ELControl_SysMenuSupport(p) FUNC(p)->SysMenuSupport(PARAM(p))
#  define ELControl_ActiveChannel(p) FUNC(p)->ActiveChannel(PARAM(p))
#  define ELControl_UserMathExpression(p, a) FUNC(p)->UserMathExpression(PARAM_(p) a)
#  define ELControl_ShowSelectChannelDlg(p) FUNC(p)->ShowSelectChannelDlg(PARAM(p))
#  define ELControl_ShowPropertiesDlg(p) FUNC(p)->ShowPropertiesDlg(PARAM(p))
#  define ELControl_GetChannelOptions(p, a, b, c) FUNC(p)->GetChannelOptions(PARAM_(p) a, b, c)
#  define ELControl_SetChannelOptions(p, a, b) FUNC(p)->SetChannelOptions(PARAM_(p) a, b)
# endif

# undef INTERFACE
# define INTERFACE ELGenericBuffer
DECLARE_INTERFACE(ELGenericBuffer) {
  STDMETHOD_(void, NewData)(THIS_ BYTE * buffer, UINT size) PURE;
}; // ELGenericBuffer
typedef ELGenericBuffer *pELGenericBuffer;

# if defined(__cplusplus)
template<typename _Class>
struct my_generic_buffer : public ELGenericBuffer {
  my_generic_buffer() { }
  STDMETHODIMP_(void) NewData( BYTE * buffer, UINT size) { _data->NewData(buffer, size); }
  _Class *_data;
}; // my_generic_buffer
# endif

# ifndef EL_IGNORE_HELPER_MACROS
#  define ELGenericBuffer_NewData(p, a, b) FUNC(p)->NewData(PARAM_(p) a, b)
# endif

#ifndef EL_PASSWORD_VERSION
# define EL_PASSWORD_VERSION 1
#endif
# undef INTERFACE
# define INTERFACE ELPasswordControl
DECLARE_INTERFACE(ELPasswordControl) {
  STDMETHOD_(DWORD, InterfaceVersion)(THIS) PURE;
  STDMETHOD_(UINT, Unlock)(THIS_ const char * password) PURE;
  STDMETHOD_(UINT, Lock)(THIS_ const char * password) PURE;
  STDMETHOD_(BOOL, IsLocked)(THIS) PURE;
  STDMETHOD_(UINT, Clear)(THIS) PURE;
}; // ELPasswordControl
typedef ELPasswordControl *pELPasswordControl;

# ifndef EL_IGNORE_HELPER_MACROS
#  define ELPasswordControl_InterfaceVersion(p) FUNC(p)->InterfaceVersion(PARAM(p))
#  define ELPasswordControl_Unlock(p, a) FUNC(p)->Unlock(PARAM_(p) a)
#  define ELPasswordControl_Lock(p, a) FUNC(p)->Lock(PARAM_(p) a)
#  define ELPasswordControl_IsLocked(p) FUNC(p)->IsLocked(PARAM(p))
#  define ELPasswordControl_Clear(p) FUNC(p)->Clear(PARAM(p))
# endif

#ifndef EL_CAN_SNIFFER_VERSION
# define EL_CAN_SNIFFER_VERSION 1
#endif
# undef INTERFACE
# define INTERFACE ELCANSniffer
DECLARE_INTERFACE(ELCANSniffer) {
  STDMETHOD_(DWORD, InterfaceVersion)(THIS) PURE;
// ElementSize
//   Returns the size in bytes of the underlying data used.
  STDMETHOD_(UINT, ElementSize)(THIS) PURE;
  STDMETHOD_(UINT, RegisterBuffer)(THIS_ pELGenericBuffer buffer) PURE;
  STDMETHOD_(UINT, UnregisterBuffer)(THIS_ pELGenericBuffer buffer) PURE;
  STDMETHOD_(UINT, SwapEndian)(THIS_ BYTE * buffer, UINT size) PURE;
}; // ELCANSniffer
typedef ELCANSniffer *pELCANSniffer;

# ifndef EL_IGNORE_HELPER_MACROS
#  define ELCANSniffer_InterfaceVersion(p) FUNC(p)->InterfaceVersion(PARAM(p))
#  define ELCANSniffer_ElementSize(p) FUNC(p)->ElementSize(PARAM(p))
#  define ELCANSniffer_RegisterBuffer(p, a) FUNC(p)->RegisterBuffer(PARAM_(p) a)
#  define ELCANSniffer_UnregisterBuffer(p, a) FUNC(p)->UnregisterBuffer(PARAM_(p) a)
#  define ELCANSniffer_SwapEndian(p, a, b) FUNC(p)->SwapEndian(PARAM_(p) a, b)
# endif

#ifndef EL_GENERIC_INFO_VERSION
# define EL_GENERIC_INFO_VERSION 1
#endif
# undef INTERFACE
# define INTERFACE ELGenericInfo
DECLARE_INTERFACE(ELGenericInfo) {
  STDMETHOD_(DWORD, InterfaceVersion)(THIS) PURE;
  STDMETHOD_(UINT, Index)(THIS) PURE;
  STDMETHOD_(UINT, Value)(THIS) PURE;
  STDMETHOD_(const char *, Name)(THIS) PURE;
  STDMETHOD_(void, InputRange)(THIS_ WORD * minimum, WORD * maximum) PURE;
}; // ELGenericInfo
typedef ELGenericInfo *pELGenericInfo;

# ifndef EL_IGNORE_HELPER_MACROS
#  define ELGenericInfo_InterfaceVersion(p) FUNC(p)->InterfaceVersion(PARAM(p))
#  define ELGenericInfo_Index(p) FUNC(p)->Index(PARAM(p))
#  define ELGenericInfo_Value(p) FUNC(p)->Value(PARAM(p))
#  define ELGenericInfo_Name(p) FUNC(p)->Name(PARAM(p))
#  define ELGenericInfo_InputRange(p, a, b) FUNC(p)->InputRange(PARAM_(p) a, b)
# endif

#ifndef EL_CAM_CRANK_INFO_VERSION
# define EL_CAM_CRANK_INFO_VERSION 1
#endif
# undef INTERFACE
# define INTERFACE ELCamCrankInfo
DECLARE_INTERFACE(ELCamCrankInfo) {
  STDMETHOD_(DWORD, InterfaceVersion)(THIS) PURE;
  STDMETHOD_(UINT, NumberOfTeeth)(THIS) PURE;
  STDMETHOD_(CAMCRANKOPTION, Option)(THIS) PURE;
}; // ELCamCrankInfo
typedef ELCamCrankInfo *pELCamCrankInfo;

# ifndef EL_IGNORE_HELPER_MACROS
#  define ELCamCrankInfo_InterfaceVersion(p) FUNC(p)->InterfaceVersion(PARAM(p))
#  define ELCamCrankInfo_NumberOfTeeth(p) FUNC(p)->NumberOfTeeth(PARAM(p))
#  define ELCamCrankInfo_Option(p) FUNC(p)->Option(PARAM(p))
# endif

#ifndef EL_TIMING_TYPE_VERSION
# define EL_TIMING_TYPE_VERSION 1
#endif
# undef INTERFACE
# define INTERFACE ELTimingType
DECLARE_INTERFACE_(ELTimingType, ELGenericInfo) {
  STDMETHOD_(DWORD, InterfaceVersion)(THIS) PURE;
  STDMETHOD_(UINT, Index)(THIS) PURE;
  STDMETHOD_(UINT, Value)(THIS) PURE;
  STDMETHOD_(const char *, Name)(THIS) PURE;
  STDMETHOD_(void, InputRange)(THIS_ WORD * minimum, WORD * maximum) PURE;
  STDMETHOD_(pELCamCrankInfo, CrankInfo)(THIS) PURE;
  STDMETHOD_(pELCamCrankInfo, CamInfo)(THIS_ UINT index) PURE;
  STDMETHOD_(UINT, NumberOfCams)(THIS) PURE;
}; // ELTimingType
typedef ELTimingType *pELTimingType;

# ifndef EL_IGNORE_HELPER_MACROS
#  define ELTimingType_CrankInfo(p) FUNC(p)->CrankInfo(PARAM(p))
#  define ELTimingType_CamInfo(p, a) FUNC(p)->CamInfo(PARAM_(p) a)
#  define ELTimingType_NumberOfCams(p) FUNC(p)->NumberOfCams(PARAM(p))
# endif

#ifndef EL_CPU_PIN_MODE_VERSION
# define EL_CPU_PIN_MODE_VERSION 1
#endif
# undef INTERFACE
# define INTERFACE ELCPUPinMode
DECLARE_INTERFACE_(ELCPUPinMode, ELGenericInfo) {
  STDMETHOD_(DWORD, InterfaceVersion)(THIS) PURE;
  STDMETHOD_(UINT, Index)(THIS) PURE;
  STDMETHOD_(UINT, Value)(THIS) PURE;
  STDMETHOD_(const char *, Name)(THIS) PURE;
  STDMETHOD_(void, InputRange)(THIS_ WORD * minimum, WORD * maximum) PURE;
  STDMETHOD_(UINT, NumberOfLocals)(THIS) PURE;
}; // ELCPUPinMode
typedef ELCPUPinMode *pELCPUPinMode;

# ifndef EL_IGNORE_HELPER_MACROS
#  define ELCPUPinMode_NumberOfLocals(p) FUNC(p)->NumberOfLocals(PARAM(p))
# endif

#ifndef EL_MATH_TOKEN_VERSION
# define EL_MATH_TOKEN_VERSION 1
#endif
# undef INTERFACE
# define INTERFACE ELMathToken
DECLARE_INTERFACE_(ELMathToken, ELGenericInfo) {
  STDMETHOD_(DWORD, InterfaceVersion)(THIS) PURE;
  STDMETHOD_(UINT, Index)(THIS) PURE;
  STDMETHOD_(UINT, Value)(THIS) PURE;
  STDMETHOD_(const char *, Name)(THIS) PURE;
  STDMETHOD_(void, InputRange)(THIS_ WORD * minimum, WORD * maximum) PURE;
  STDMETHOD_(INT, StackUse)(THIS) PURE;
  STDMETHOD_(WORD, NumberOfChildren)(THIS) PURE;
// Duplicate
//   Does not copy the token, returns the other token that has a duplicate Name().
  STDMETHOD_(pELMathToken, Duplicate)(THIS) PURE;
}; // ELMathToken
typedef ELMathToken *pELMathToken;

# ifndef EL_IGNORE_HELPER_MACROS
#  define ELMathToken_StackUse(p) FUNC(p)->StackUse(PARAM(p))
#  define ELMathToken_NumberOfChildren(p) FUNC(p)->NumberOfChildren(PARAM(p))
#  define ELMathToken_Duplicate(p) FUNC(p)->Duplicate(PARAM(p))
# endif

#ifndef EL_ITEM_TYPE_VERSION
# define EL_ITEM_TYPE_VERSION 2
#endif
# undef INTERFACE
# define INTERFACE ELItemType
DECLARE_INTERFACE_(ELItemType, ELGenericInfo) {
  STDMETHOD_(DWORD, InterfaceVersion)(THIS) PURE;
  STDMETHOD_(UINT, Index)(THIS) PURE;
  STDMETHOD_(UINT, Value)(THIS) PURE;
  STDMETHOD_(const char *, Name)(THIS) PURE;
  STDMETHOD_(void, InputRange)(THIS_ WORD * minimum, WORD * maximum) PURE;
  STDMETHOD_(BOOL, Creatable)(THIS) PURE;
# if EL_ITEM_TYPE_VERSION >= 2
  STDMETHOD_(BOOL, HardwareProcessed)(THIS) PURE;
# endif
}; // ELItemType
typedef ELItemType *pELItemType;

# ifndef EL_IGNORE_HELPER_MACROS
#  define ELItemType_Creatable(p) FUNC(p)->Creatable(PARAM(p))
# if EL_ITEM_TYPE_VERSION >= 2
#  define ELItemType_HardwareProcessed(p) FUNC(p)->HardwareProcessed(PARAM(p))
# endif
# endif

// This interface is used as a wrapper for ELGenericInfo when endianess is required during model development.
# undef INTERFACE
# define INTERFACE ELEndianess
DECLARE_INTERFACE_(ELEndianess, ELGenericInfo) {
  STDMETHOD_(DWORD, InterfaceVersion)(THIS) PURE;
  STDMETHOD_(UINT, Index)(THIS) PURE;
  STDMETHOD_(UINT, Value)(THIS) PURE;
  STDMETHOD_(const char *, Name)(THIS) PURE;
  STDMETHOD_(void, InputRange)(THIS_ WORD * minimum, WORD * maximum) PURE;
}; // ELEndianess
typedef ELEndianess *pELEndianess;

// This interface is used as a wrapper for ELGenericInfo when a bus channel is required during model development.
# undef INTERFACE
# define INTERFACE ELBusChannel
DECLARE_INTERFACE_(ELBusChannel, ELGenericInfo) {
  STDMETHOD_(DWORD, InterfaceVersion)(THIS) PURE;
  STDMETHOD_(UINT, Index)(THIS) PURE;
  STDMETHOD_(UINT, Value)(THIS) PURE;
  STDMETHOD_(const char *, Name)(THIS) PURE;
  STDMETHOD_(void, InputRange)(THIS_ WORD * minimum, WORD * maximum) PURE;
}; // ELBusChannel
typedef ELBusChannel *pELBusChannel;

// This interface is used as a wrapper for ELGenericInfo when a bus direction is required during model development.
# undef INTERFACE
# define INTERFACE ELBusDirection
DECLARE_INTERFACE_(ELBusDirection, ELGenericInfo) {
  STDMETHOD_(DWORD, InterfaceVersion)(THIS) PURE;
  STDMETHOD_(UINT, Index)(THIS) PURE;
  STDMETHOD_(UINT, Value)(THIS) PURE;
  STDMETHOD_(const char *, Name)(THIS) PURE;
  STDMETHOD_(void, InputRange)(THIS_ WORD * minimum, WORD * maximum) PURE;
}; // ELBusDirection
typedef ELBusDirection *pELBusDirection;

// This interface is used as a wrapper for ELGenericInfo when a bus direction is required during model development.
# undef INTERFACE
# define INTERFACE ELBusTxMode
DECLARE_INTERFACE_(ELBusTxMode, ELGenericInfo) {
  STDMETHOD_(DWORD, InterfaceVersion)(THIS) PURE;
  STDMETHOD_(UINT, Index)(THIS) PURE;
  STDMETHOD_(UINT, Value)(THIS) PURE;
  STDMETHOD_(const char *, Name)(THIS) PURE;
  STDMETHOD_(void, InputRange)(THIS_ WORD * minimum, WORD * maximum) PURE;
}; // ELBusTxMode
typedef ELBusTxMode *pELBusTxMode;

// This interface is used as a wrapper for ELGenericInfo when a latch edge is required during model development.
# undef INTERFACE
# define INTERFACE ELLatchEdge
DECLARE_INTERFACE_(ELLatchEdge, ELGenericInfo) {
  STDMETHOD_(DWORD, InterfaceVersion)(THIS) PURE;
  STDMETHOD_(UINT, Index)(THIS) PURE;
  STDMETHOD_(UINT, Value)(THIS) PURE;
  STDMETHOD_(const char *, Name)(THIS) PURE;
  STDMETHOD_(void, InputRange)(THIS_ WORD * minimum, WORD * maximum) PURE;
}; // ELLatchEdge
typedef ELLatchEdge *pELLatchEdge;

// This interface is used as a wrapper for ELGenericInfo when a latch start state is required during model development.
# undef INTERFACE
# define INTERFACE ELLatchStartState
DECLARE_INTERFACE_(ELLatchStartState, ELGenericInfo) {
  STDMETHOD_(DWORD, InterfaceVersion)(THIS) PURE;
  STDMETHOD_(UINT, Index)(THIS) PURE;
  STDMETHOD_(UINT, Value)(THIS) PURE;
  STDMETHOD_(const char *, Name)(THIS) PURE;
  STDMETHOD_(void, InputRange)(THIS_ WORD * minimum, WORD * maximum) PURE;
}; // ELLatchStartState
typedef ELLatchStartState *pELLatchStartState;

#ifndef EL_DATA_TYPE_VERSION
# define EL_DATA_TYPE_VERSION 1
#endif
# undef INTERFACE
# define INTERFACE ELDataType
DECLARE_INTERFACE_(ELDataType, ELGenericInfo) {
  STDMETHOD_(DWORD, InterfaceVersion)(THIS) PURE;
  STDMETHOD_(UINT, Index)(THIS) PURE;
  STDMETHOD_(UINT, Value)(THIS) PURE;
  STDMETHOD_(const char *, Name)(THIS) PURE;
  STDMETHOD_(void, InputRange)(THIS_ WORD * minimum, WORD * maximum) PURE;
  STDMETHOD_(UINT, NumberOfBits)(THIS) PURE;
}; // ELDataType
typedef ELDataType *pELDataType;

# ifndef EL_IGNORE_HELPER_MACROS
#  define ELDataType_NumberOfBits(p) FUNC(p)->NumberOfBits(PARAM(p))
# endif

#ifndef EL_GENERIC_INFO_LIST_VERSION
# define EL_GENERIC_INFO_LIST_VERSION 1
#endif
# undef INTERFACE
# define INTERFACE ELGenericInfoList
DECLARE_INTERFACE(ELGenericInfoList) {
  STDMETHOD_(DWORD, InterfaceVersion)(THIS) PURE;
  STDMETHOD_(UINT, Count)(THIS) PURE;
  STDMETHOD_(pELGenericInfo, Info)(THIS_ UINT index) PURE;
  STDMETHOD_(pELGenericInfo, InfoByValue)(THIS_ UINT value) PURE;
  STDMETHOD_(pELGenericInfo, InfoByName)(THIS_ const char * name) PURE;
}; // ELGenericInfoList
typedef ELGenericInfoList *pELGenericInfoList;

# ifndef EL_IGNORE_HELPER_MACROS
#  define ELGenericInfoList_InterfaceVersion(p) FUNC(p)->InterfaceVersion(PARAM(p))
#  define ELGenericInfoList_Count(p) FUNC(p)->Count(PARAM(p))
#  define ELGenericInfoList_Info(p, a) FUNC(p)->Info(PARAM_(p) a)
#  define ELGenericInfoList_InfoByValue(p, a) FUNC(p)->InfoByValue(PARAM_(p) a)
#  define ELGenericInfoList_InfoByName(p, a) FUNC(p)->InfoByName(PARAM_(p) a)
# endif

#ifndef EL_MODELER_VERSION
# define EL_MODELER_VERSION 2
#endif
# undef INTERFACE
# define INTERFACE ELModeler
DECLARE_INTERFACE(ELModeler) {
  STDMETHOD_(DWORD, InterfaceVersion)(THIS) PURE;
  STDMETHOD_(WORD, NextAvailableChannelNumber)(THIS) PURE;
// NewItem
//   Unlike CreateItem, this only allocates space used to fill in the item prior to sending to target.
  STDMETHOD_(UINT, NewItem)(THIS_ pELItemType type, const char * name, pELItem * item) PURE;
// FreeItem
//   Frees the memory used from the given item.  Item is expected to have been created via NewItem.
  STDMETHOD_(void, FreeItem)(THIS_ pELItem * item) PURE;
  STDMETHOD_(VALIDATESTATUS, ValidateItem)(THIS_ pELItem item) PURE;
  STDMETHOD_(UINT, GetItem)(THIS_ const char * name, BOOL from_ram, pELItem * item) PURE;
  STDMETHOD_(UINT, GetItemByChannel)(THIS_ WORD channel, BOOL from_ram, pELItem * item) PURE;
// CreateItem
//   Adds the item to the target (model).
  STDMETHOD_(UINT, CreateItem)(THIS_ pELItem item, VALIDATESTATUS * out_status) PURE;
  STDMETHOD_(UINT, ModifyItem)(THIS_ pELItem item, VALIDATESTATUS * out_status) PURE;
  STDMETHOD_(UINT, DeleteItem)(THIS_ pELItem item, DELETEITEMOPTION option) PURE;
// CreateExtern
//   Actually creates the extern on the target, or returns an already existing extern.
  STDMETHOD_(UINT, CreateExtern)(THIS_ const char * name, BOOL rom_based, pELExtern * out_extern) PURE;
# if EL_MODELER_VERSION >= 2
  STDMETHOD_(UINT, RenameItem)(THIS_ const char * old_name, const char * new_name) PURE;
# endif
}; // ELModeler
typedef ELModeler *pELModeler;

# ifndef EL_IGNORE_HELPER_MACROS
#  define ELModeler_InterfaceVersion(p) FUNC(p)->InterfaceVersion(PARAM(p))
#  define ELModeler_NextAvailableChannelNumber(p) FUNC(p)->NextAvailableChannelNumber(PARAM(p))
#  define ELModeler_NewItem(p, a, b, c) FUNC(p)->NewItem(PARAM_(p) a, b, c)
#  define ELModeler_FreeItem(p, a) FUNC(p)->FreeItem(PARAM_(p) a)
#  define ELModeler_ValidateItem(p, a) FUNC(p)->ValidateItem(PARAM_(p) a)
#  define ELModeler_GetItem(p, a, b, c) FUNC(p)->GetItem(PARAM_(p) a, b, c)
#  define ELModeler_GetItemByChannel(p, a, b, c) FUNC(p)->GetItemByChannel(PARAM_(p) a, b, c)
#  define ELModeler_CreateItem(p, a, b) FUNC(p)->CreateItem(PARAM_(p) a, b)
#  define ELModeler_ModifyItem(p, a, b) FUNC(p)->ModifyItem(PARAM_(p) a, b)
#  define ELModeler_DeleteItem(p, a, b) FUNC(p)->DeleteItem(PARAM_(p) a, b)
#  define ELModeler_CreateExtern(p, a, b, c) FUNC(p)->CreateExtern(PARAM_(p) a, b, c)
# if EL_MODELER_VERSION >= 2
#  define ELModeler_RenameItem(p, a, b) FUNC(p)->RenameItem(PARAM_(p) a, b)
# endif
# endif

#ifndef EL_TARGET_VERSION
# define EL_TARGET_VERSION 3
#endif
# undef INTERFACE
# define INTERFACE ELTarget
DECLARE_INTERFACE(ELTarget) {
  STDMETHOD_(DWORD, InterfaceVersion)(THIS) PURE;
  STDMETHOD_(BOOL, IsFullTarget)(THIS) PURE;
  STDMETHOD_(UINT, GetVersion)(THIS_ pELTargetVersion version) PURE;
  STDMETHOD_(UINT, GetName)(THIS_ pELString * out_name) PURE;
  STDMETHOD_(UINT, GetModifiableItem)(THIS_ const char * name, pConfigurationItemHeader_modifiable_TS out_item) PURE;
  STDMETHOD_(UINT, SetModifiableItem)(THIS_ const char * name, pConfigurationItemHeader_modifiable_TS item) PURE;
  STDMETHOD_(UINT, GetHarnessPin)(THIS_ BYTE index, pPeripheral_HarnessPinDescriptorForPlugin_TS harness_pin) PURE;
  STDMETHOD_(UINT, Commit)(THIS) PURE;
  STDMETHOD_(UINT, EAL_stop)(THIS) PURE;
  STDMETHOD_(UINT, EAL_start)(THIS) PURE;
  STDMETHOD_(UINT, Validate)(THIS_ pGenericStatusStringResponse_DTS pGSSR_DTS) PURE;
  STDMETHOD_(UINT, GetNameFromChannel)(THIS_ WORD channel_number, pELString * out_name) PURE;
  STDMETHOD_(UINT, GetChannelFromName)(THIS_ const char * channel_name, WORD * out_channel) PURE;
  STDMETHOD_(BOOL, Connected)(THIS) PURE;
# if EL_TARGET_VERSION >= 2
  STDMETHOD_(UINT, Password)(THIS_ pELPasswordControl * controller) PURE;
# endif
# if EL_TARGET_VERSION >= 2
  STDMETHOD_(UINT, CANSniffer)(THIS_ CANCHANNEL channel, pELCANSniffer * sniffer) PURE;
# endif
# if EL_TARGET_VERSION >= 2
  STDMETHOD_(UINT, InfoList)(THIS_ TARGETINFO on, pELGenericInfoList * out_list) PURE;
# endif
// ItemList
//   Reads the entire item list from the target.  May take a while.
# if EL_TARGET_VERSION >= 3
  STDMETHOD_(UINT, ItemList)(THIS_ ITEMFILTER filter, pELItemList * out_list) PURE;
# endif
// ExternList
//   Yields a list of existing externs on the target.
# if EL_TARGET_VERSION >= 3
  STDMETHOD_(UINT, ExternList)(THIS_ DWORD options, pELExternList * out_list) PURE;
# endif
// Modeler
//   Yields the interface used for model editing for the target.
# if EL_TARGET_VERSION >= 3
  STDMETHOD_(UINT, Modeler)(THIS_ pELModeler * modeler) PURE;
# endif
}; // ELTarget
typedef ELTarget *pELTarget;

# ifndef EL_IGNORE_HELPER_MACROS
#  define ELTarget_InterfaceVersion(p) FUNC(p)->InterfaceVersion(PARAM(p))
#  define ELTarget_IsFullTarget(p) FUNC(p)->IsFullTarget(PARAM(p))
#  define ELTarget_GetVersion(p, a) FUNC(p)->GetVersion(PARAM_(p) a)
#  define ELTarget_GetName(p, a) FUNC(p)->GetName(PARAM_(p) a)
#  define ELTarget_GetModifiableItem(p, a, b) FUNC(p)->GetModifiableItem(PARAM_(p) a, b)
#  define ELTarget_SetModifiableItem(p, a, b) FUNC(p)->SetModifiableItem(PARAM_(p) a, b)
#  define ELTarget_GetHarnessPin(p, a, b) FUNC(p)->GetHarnessPin(PARAM_(p) a, b)
#  define ELTarget_Commit(p) FUNC(p)->Commit(PARAM(p))
#  define ELTarget_EAL_stop(p) FUNC(p)->EAL_stop(PARAM(p))
#  define ELTarget_EAL_start(p) FUNC(p)->EAL_start(PARAM(p))
#  define ELTarget_Validate(p, a) FUNC(p)->Validate(PARAM_(p) a)
#  define ELTarget_GetNameFromChannel(p, a, b) FUNC(p)->GetNameFromChannel(PARAM_(p) a, b)
#  define ELTarget_GetChannelFromName(p, a, b) FUNC(p)->GetChannelFromName(PARAM_(p) a, b)
#  define ELTarget_Connected(p) FUNC(p)->Connected(PARAM(p))
# if EL_TARGET_VERSION >= 2
#  define ELTarget_Password(p, a) FUNC(p)->Password(PARAM_(p) a)
# endif
# if EL_TARGET_VERSION >= 2
#  define ELTarget_CANSniffer(p, a, b) FUNC(p)->CANSniffer(PARAM_(p) a, b)
# endif
# if EL_TARGET_VERSION >= 2
#  define ELTarget_InfoList(p, a, b) FUNC(p)->InfoList(PARAM_(p) a, b)
# endif
# if EL_TARGET_VERSION >= 3
#  define ELTarget_ItemList(p, a, b) FUNC(p)->ItemList(PARAM_(p) a, b)
# endif
# if EL_TARGET_VERSION >= 3
#  define ELTarget_ExternList(p, a, b) FUNC(p)->ExternList(PARAM_(p) a, b)
# endif
# if EL_TARGET_VERSION >= 3
#  define ELTarget_Modeler(p, a) FUNC(p)->Modeler(PARAM_(p) a)
# endif
# endif

#ifndef EL_CONFIGURATION_VERSION
# define EL_CONFIGURATION_VERSION 2
#endif
# undef INTERFACE
# define INTERFACE ELConfiguration
DECLARE_INTERFACE_(ELConfiguration, ELTarget) {
  STDMETHOD_(DWORD, InterfaceVersion)(THIS) PURE;
  STDMETHOD_(BOOL, IsFullTarget)(THIS) PURE;
  STDMETHOD_(UINT, GetVersion)(THIS_ pELTargetVersion version) PURE;
  STDMETHOD_(UINT, GetName)(THIS_ pELString * out_name) PURE;
  STDMETHOD_(UINT, GetModifiableItem)(THIS_ const char * name, pConfigurationItemHeader_modifiable_TS out_item) PURE;
  STDMETHOD_(UINT, SetModifiableItem)(THIS_ const char * name, pConfigurationItemHeader_modifiable_TS item) PURE;
  STDMETHOD_(UINT, GetHarnessPin)(THIS_ BYTE index, pPeripheral_HarnessPinDescriptorForPlugin_TS harness_pin) PURE;
  STDMETHOD_(UINT, Commit)(THIS) PURE;
  STDMETHOD_(UINT, EAL_stop)(THIS) PURE;
  STDMETHOD_(UINT, EAL_start)(THIS) PURE;
  STDMETHOD_(UINT, Validate)(THIS_ pGenericStatusStringResponse_DTS pGSSR_DTS) PURE;
  STDMETHOD_(UINT, GetNameFromChannel)(THIS_ WORD channel_number, pELString * out_name) PURE;
  STDMETHOD_(UINT, GetChannelFromName)(THIS_ const char * channel_name, WORD * out_channel) PURE;
  STDMETHOD_(BOOL, Connected)(THIS) PURE;
# if EL_CONFIGURATION_VERSION >= 2
  STDMETHOD_(UINT, Password)(THIS_ pELPasswordControl * controller) PURE;
# endif
# if EL_CONFIGURATION_VERSION >= 2
  STDMETHOD_(UINT, CANSniffer)(THIS_ CANCHANNEL channel, pELCANSniffer * sniffer) PURE;
# endif
# if EL_CONFIGURATION_VERSION >= 2
  STDMETHOD_(UINT, InfoList)(THIS_ TARGETINFO on, pELGenericInfoList * out_list) PURE;
# endif
// ItemList
//   Reads the entire item list from the target.  May take a while.
# if EL_CONFIGURATION_VERSION >= 3
  STDMETHOD_(UINT, ItemList)(THIS_ ITEMFILTER filter, pELItemList * out_list) PURE;
# endif
// ExternList
//   Yields a list of existing externs on the target.
# if EL_CONFIGURATION_VERSION >= 3
  STDMETHOD_(UINT, ExternList)(THIS_ DWORD options, pELExternList * out_list) PURE;
# endif
// Modeler
//   Yields the interface used for model editing for the target.
# if EL_CONFIGURATION_VERSION >= 3
  STDMETHOD_(UINT, Modeler)(THIS_ pELModeler * modeler) PURE;
# endif
  STDMETHOD_(UINT, ItemCount)(THIS) PURE;
  STDMETHOD_(UINT, Item)(THIS_ UINT index, pConfigurationItemHeader_modifiable_TS mod_item) PURE;
}; // ELConfiguration
typedef ELConfiguration *pELConfiguration;

# ifndef EL_IGNORE_HELPER_MACROS
#  define ELConfiguration_ItemCount(p) FUNC(p)->ItemCount(PARAM(p))
#  define ELConfiguration_Item(p, a, b) FUNC(p)->Item(PARAM_(p) a, b)
# endif

# undef INTERFACE
# define INTERFACE ELLayoutManager
DECLARE_INTERFACE(ELLayoutManager) {
  STDMETHOD_(void, PageAdded)(THIS_ UINT index, const char * name) PURE;
  STDMETHOD_(void, PageRemoved)(THIS_ UINT index) PURE;
  STDMETHOD_(void, PageChanged)(THIS_ UINT index) PURE;
  STDMETHOD_(void, PageNameChanged)(THIS_ UINT index, const char * new_name) PURE;
  STDMETHOD_(void, PageSwap)(THIS_ UINT index1, UINT index2) PURE;
  STDMETHOD_(void, PageMoved)(THIS_ UINT from_index, UINT to_index) PURE;
  STDMETHOD_(void, PageSaved)(THIS_ UINT * indices, UINT count) PURE;
  STDMETHOD_(void, VisiblePageChanged)(THIS_ UINT index) PURE;
  STDMETHOD_(void, LayoutChanged)(THIS) PURE;
  STDMETHOD_(void, LayoutSaved)(THIS) PURE;
}; // ELLayoutManager
typedef ELLayoutManager *pELLayoutManager;

# if defined(__cplusplus)
template<typename _Class>
struct my_layout_manager : public ELLayoutManager {
  my_layout_manager() { }
  STDMETHODIMP_(void) PageAdded( UINT index, const char * name) { _data->PageAdded(index, name); }
  STDMETHODIMP_(void) PageRemoved( UINT index) { _data->PageRemoved(index); }
  STDMETHODIMP_(void) PageChanged( UINT index) { _data->PageChanged(index); }
  STDMETHODIMP_(void) PageNameChanged( UINT index, const char * new_name) { _data->PageNameChanged(index, new_name); }
  STDMETHODIMP_(void) PageSwap( UINT index1, UINT index2) { _data->PageSwap(index1, index2); }
  STDMETHODIMP_(void) PageMoved( UINT from_index, UINT to_index) { _data->PageMoved(from_index, to_index); }
  STDMETHODIMP_(void) PageSaved( UINT * indices, UINT count) { _data->PageSaved(indices, count); }
  STDMETHODIMP_(void) VisiblePageChanged( UINT index) { _data->VisiblePageChanged(index); }
  STDMETHODIMP_(void) LayoutChanged() { _data->LayoutChanged(); }
  STDMETHODIMP_(void) LayoutSaved() { _data->LayoutSaved(); }
  _Class *_data;
}; // my_layout_manager
# endif

# ifndef EL_IGNORE_HELPER_MACROS
#  define ELLayoutManager_PageAdded(p, a, b) FUNC(p)->PageAdded(PARAM_(p) a, b)
#  define ELLayoutManager_PageRemoved(p, a) FUNC(p)->PageRemoved(PARAM_(p) a)
#  define ELLayoutManager_PageChanged(p, a) FUNC(p)->PageChanged(PARAM_(p) a)
#  define ELLayoutManager_PageNameChanged(p, a, b) FUNC(p)->PageNameChanged(PARAM_(p) a, b)
#  define ELLayoutManager_PageSwap(p, a, b) FUNC(p)->PageSwap(PARAM_(p) a, b)
#  define ELLayoutManager_PageMoved(p, a, b) FUNC(p)->PageMoved(PARAM_(p) a, b)
#  define ELLayoutManager_PageSaved(p, a, b) FUNC(p)->PageSaved(PARAM_(p) a, b)
#  define ELLayoutManager_VisiblePageChanged(p, a) FUNC(p)->VisiblePageChanged(PARAM_(p) a)
#  define ELLayoutManager_LayoutChanged(p) FUNC(p)->LayoutChanged(PARAM(p))
#  define ELLayoutManager_LayoutSaved(p) FUNC(p)->LayoutSaved(PARAM(p))
# endif

# undef INTERFACE
# define INTERFACE ELHook
DECLARE_INTERFACE(ELHook) {
  STDMETHOD_(void, BeforeCall)(THIS_ HOOKTYPE option) PURE;
  STDMETHOD_(void, AfterCall)(THIS_ HOOKTYPE option) PURE;
}; // ELHook
typedef ELHook *pELHook;

# if defined(__cplusplus)
template<typename _Class>
struct my_hook : public ELHook {
  my_hook() { }
  STDMETHODIMP_(void) BeforeCall( HOOKTYPE option) { _data->BeforeCall(option); }
  STDMETHODIMP_(void) AfterCall( HOOKTYPE option) { _data->AfterCall(option); }
  _Class *_data;
}; // my_hook
# endif

# ifndef EL_IGNORE_HELPER_MACROS
#  define ELHook_BeforeCall(p, a) FUNC(p)->BeforeCall(PARAM_(p) a)
#  define ELHook_AfterCall(p, a) FUNC(p)->AfterCall(PARAM_(p) a)
# endif

#ifndef EL_LAYOUT_VERSION
# define EL_LAYOUT_VERSION 2
#endif
# undef INTERFACE
# define INTERFACE ELLayout
DECLARE_INTERFACE(ELLayout) {
  STDMETHOD_(DWORD, InterfaceVersion)(THIS) PURE;
  STDMETHOD_(UINT, Open)(THIS_ const char * file) PURE;
  STDMETHOD_(UINT, Append)(THIS_ const char * file) PURE;
  STDMETHOD_(UINT, Save)(THIS_ const char * file, LAYOUTSAVEOPTION option) PURE;
  STDMETHOD_(UINT, SavePages)(THIS_ const char * file, UINT * indices, UINT index_count, LAYOUTSAVEOPTION option) PURE;
  STDMETHOD_(void, EnterModalSection)(THIS) PURE;
  STDMETHOD_(void, LeaveModalSection)(THIS) PURE;
  STDMETHOD_(UINT, RegisterWindow)(THIS_ pELWindow window) PURE;
  STDMETHOD_(UINT, UnregisterWindow)(THIS_ pELWindow window) PURE;
  STDMETHOD_(UINT, PinWindow)(THIS_ pELWindow window, BOOL pin) PURE;
  STDMETHOD_(UINT, WindowMoveStart)(THIS_ pELWindow window) PURE;
  STDMETHOD_(UINT, WindowMoving)(THIS_ pELWindow window) PURE;
  STDMETHOD_(UINT, WindowMoveEnd)(THIS_ pELWindow window) PURE;
  STDMETHOD_(UINT, WindowClosed)(THIS_ pELWindow window) PURE;
  STDMETHOD_(void, UpdateSystemMenu)(THIS_ pELControlWindow control_window) PURE;
  STDMETHOD_(UINT, RegisterControl)(THIS_ pELControl control) PURE;
  STDMETHOD_(UINT, UnregisterControl)(THIS_ pELControl control) PURE;
  STDMETHOD_(UINT, DuplicateControl)(THIS_ pELControl control) PURE;
  STDMETHOD_(UINT, RegisterManager)(THIS_ pELLayoutManager manager) PURE;
  STDMETHOD_(UINT, UnregisterManager)(THIS_ pELLayoutManager manager) PURE;
  STDMETHOD_(UINT, Clear)(THIS_ LAYOUTCLEAROPTION option) PURE;
  STDMETHOD_(UINT, PageCount)(THIS) PURE;
  STDMETHOD_(UINT, GetPageName)(THIS_ UINT index, pELString * out_name) PURE;
  STDMETHOD_(UINT, SetPageName)(THIS_ UINT index, const char * name) PURE;
  STDMETHOD_(UINT, PageIndex)(THIS_ pELWindow window, UINT * out_index) PURE;
  STDMETHOD_(UINT, VisiblePageIndex)(THIS_ UINT * out_index) PURE;
  STDMETHOD_(UINT, GotoPage)(THIS_ UINT index) PURE;
  STDMETHOD_(UINT, NewPage)(THIS_ const char * name, UINT index) PURE;
  STDMETHOD_(UINT, DeletePage)(THIS_ UINT index, LAYOUTDELETEOPTION option) PURE;
  STDMETHOD_(UINT, MovePage)(THIS_ UINT from_index, UINT to_index) PURE;
  STDMETHOD_(UINT, SwapPages)(THIS_ UINT index1, UINT index2) PURE;
  STDMETHOD_(const pELThemeColors, ThemeColors)(THIS) PURE;
  STDMETHOD_(void, ResetTheme)(THIS) PURE;
  STDMETHOD_(void, ApplyTheme)(THIS) PURE;
# if EL_LAYOUT_VERSION >= 2
  STDMETHOD_(UINT, LoadTheme)(THIS_ const char * file) PURE;
# endif
}; // ELLayout
typedef ELLayout *pELLayout;

# ifndef EL_IGNORE_HELPER_MACROS
#  define ELLayout_InterfaceVersion(p) FUNC(p)->InterfaceVersion(PARAM(p))
#  define ELLayout_Open(p, a) FUNC(p)->Open(PARAM_(p) a)
#  define ELLayout_Append(p, a) FUNC(p)->Append(PARAM_(p) a)
#  define ELLayout_Save(p, a, b) FUNC(p)->Save(PARAM_(p) a, b)
#  define ELLayout_SavePages(p, a, b, c, d) FUNC(p)->SavePages(PARAM_(p) a, b, c, d)
#  define ELLayout_EnterModalSection(p) FUNC(p)->EnterModalSection(PARAM(p))
#  define ELLayout_LeaveModalSection(p) FUNC(p)->LeaveModalSection(PARAM(p))
#  define ELLayout_RegisterWindow(p, a) FUNC(p)->RegisterWindow(PARAM_(p) a)
#  define ELLayout_UnregisterWindow(p, a) FUNC(p)->UnregisterWindow(PARAM_(p) a)
#  define ELLayout_PinWindow(p, a, b) FUNC(p)->PinWindow(PARAM_(p) a, b)
#  define ELLayout_WindowMoveStart(p, a) FUNC(p)->WindowMoveStart(PARAM_(p) a)
#  define ELLayout_WindowMoving(p, a) FUNC(p)->WindowMoving(PARAM_(p) a)
#  define ELLayout_WindowMoveEnd(p, a) FUNC(p)->WindowMoveEnd(PARAM_(p) a)
#  define ELLayout_WindowClosed(p, a) FUNC(p)->WindowClosed(PARAM_(p) a)
#  define ELLayout_UpdateSystemMenu(p, a) FUNC(p)->UpdateSystemMenu(PARAM_(p) a)
#  define ELLayout_RegisterControl(p, a) FUNC(p)->RegisterControl(PARAM_(p) a)
#  define ELLayout_UnregisterControl(p, a) FUNC(p)->UnregisterControl(PARAM_(p) a)
#  define ELLayout_DuplicateControl(p, a) FUNC(p)->DuplicateControl(PARAM_(p) a)
#  define ELLayout_RegisterManager(p, a) FUNC(p)->RegisterManager(PARAM_(p) a)
#  define ELLayout_UnregisterManager(p, a) FUNC(p)->UnregisterManager(PARAM_(p) a)
#  define ELLayout_Clear(p, a) FUNC(p)->Clear(PARAM_(p) a)
#  define ELLayout_PageCount(p) FUNC(p)->PageCount(PARAM(p))
#  define ELLayout_GetPageName(p, a, b) FUNC(p)->GetPageName(PARAM_(p) a, b)
#  define ELLayout_SetPageName(p, a, b) FUNC(p)->SetPageName(PARAM_(p) a, b)
#  define ELLayout_PageIndex(p, a, b) FUNC(p)->PageIndex(PARAM_(p) a, b)
#  define ELLayout_VisiblePageIndex(p, a) FUNC(p)->VisiblePageIndex(PARAM_(p) a)
#  define ELLayout_GotoPage(p, a) FUNC(p)->GotoPage(PARAM_(p) a)
#  define ELLayout_NewPage(p, a, b) FUNC(p)->NewPage(PARAM_(p) a, b)
#  define ELLayout_DeletePage(p, a, b) FUNC(p)->DeletePage(PARAM_(p) a, b)
#  define ELLayout_MovePage(p, a, b) FUNC(p)->MovePage(PARAM_(p) a, b)
#  define ELLayout_SwapPages(p, a, b) FUNC(p)->SwapPages(PARAM_(p) a, b)
#  define ELLayout_ThemeColors(p) FUNC(p)->ThemeColors(PARAM(p))
#  define ELLayout_ResetTheme(p) FUNC(p)->ResetTheme(PARAM(p))
#  define ELLayout_ApplyTheme(p) FUNC(p)->ApplyTheme(PARAM(p))
# if EL_LAYOUT_VERSION >= 2
#  define ELLayout_LoadTheme(p, a) FUNC(p)->LoadTheme(PARAM_(p) a)
# endif
# endif

#ifndef EL_DIALOGS_VERSION
# define EL_DIALOGS_VERSION 1
#endif
# undef INTERFACE
# define INTERFACE ELDialogs
DECLARE_INTERFACE(ELDialogs) {
  STDMETHOD_(DWORD, InterfaceVersion)(THIS) PURE;
  STDMETHOD_(UINT, DisplayChannelList)(THIS_ pELChannelGroup group, INFOSELECT which, pELChannelInfo channel, const char * conversion) PURE;
  STDMETHOD_(UINT, DisplayFormatting)(THIS_ pELChannelInfo channel, FORMATTINGOPTION option, INFOSELECT which) PURE;
  STDMETHOD_(UINT, DisplayNumberFormat)(THIS_ pELNumberFormat formatting) PURE;
  STDMETHOD_(UINT, DisplayColorGradient)(THIS_ pELColorGradient gradient, UINT * triple_index) PURE;
  STDMETHOD_(UINT, DisplayColor)(THIS_ COLORREF * color) PURE;
  STDMETHOD_(UINT, DisplayChannelProperties)(THIS_ pELChannelInfo channel, INFOSELECT which) PURE;
}; // ELDialogs
typedef ELDialogs *pELDialogs;

# ifndef EL_IGNORE_HELPER_MACROS
#  define ELDialogs_InterfaceVersion(p) FUNC(p)->InterfaceVersion(PARAM(p))
#  define ELDialogs_DisplayChannelList(p, a, b, c, d) FUNC(p)->DisplayChannelList(PARAM_(p) a, b, c, d)
#  define ELDialogs_DisplayFormatting(p, a, b, c) FUNC(p)->DisplayFormatting(PARAM_(p) a, b, c)
#  define ELDialogs_DisplayNumberFormat(p, a) FUNC(p)->DisplayNumberFormat(PARAM_(p) a)
#  define ELDialogs_DisplayColorGradient(p, a, b) FUNC(p)->DisplayColorGradient(PARAM_(p) a, b)
#  define ELDialogs_DisplayColor(p, a) FUNC(p)->DisplayColor(PARAM_(p) a)
#  define ELDialogs_DisplayChannelProperties(p, a, b) FUNC(p)->DisplayChannelProperties(PARAM_(p) a, b)
# endif

#ifndef EL_UNIT_CONVERTER_VERSION
# define EL_UNIT_CONVERTER_VERSION 3
#endif
# undef INTERFACE
# define INTERFACE ELUnitConverter
DECLARE_INTERFACE(ELUnitConverter) {
  STDMETHOD_(DWORD, InterfaceVersion)(THIS) PURE;
  STDMETHOD_(UINT, AddConversion)(THIS_ const char * group_name, const char * from_unit, const char * to_unit, CONVERSIONOPERATOR op, float forward_coef, float reverse_coef) PURE;
  STDMETHOD_(UINT, AddGenericConversion)(THIS_ const char * group_name, const char * from_unit, const char * to_unit, const char * forward_expression, const char * reverse_expression) PURE;
  STDMETHOD_(UINT, GetGroupIndex)(THIS_ const char * group_name, UINT * out_index) PURE;
  STDMETHOD_(UINT, GetGroupName)(THIS_ UINT group_index, pELString * out_name) PURE;
  STDMETHOD_(UINT, GetUnitIndex)(THIS_ const char * unit, UINT group_index, UINT * out_index) PURE;
  STDMETHOD_(UINT, GetUnitName)(THIS_ UINT unit_index, pELString * out_name) PURE;
  STDMETHOD_(UINT, GetGroupNameFromUnit)(THIS_ UINT unit_index, pELString * out_name) PURE;
  STDMETHOD_(UINT, GetGroupIndexFromUnit)(THIS_ UINT unit_index, UINT * group_index) PURE;
  STDMETHOD_(UINT, SetConversion)(THIS_ UINT from_unit, UINT to_unit) PURE;
  STDMETHOD_(UINT, ClearConversion)(THIS_ UINT from_unit) PURE;
  STDMETHOD_(UINT, GetAllUnits)(THIS_ UINT group_index, pELArray * units) PURE;
  STDMETHOD_(UINT, GetAllCompatibleUnits)(THIS_ UINT unit, pELArray * units) PURE;
  STDMETHOD_(float, EvaluateConversion)(THIS_ UINT from_unit, UINT to_unit, float value) PURE;
# if EL_UNIT_CONVERTER_VERSION >= 2
  STDMETHOD_(UINT, GetConversion)(THIS_ UINT from_unit, UINT * to_unit) PURE;
# endif
# if EL_UNIT_CONVERTER_VERSION >= 3
  STDMETHOD_(UINT, SetGroupConversion)(THIS_ UINT group_index, UINT unit_index) PURE;
# endif
# if EL_UNIT_CONVERTER_VERSION >= 3
  STDMETHOD_(UINT, ClearGroupConversion)(THIS_ UINT group_index) PURE;
# endif
# if EL_UNIT_CONVERTER_VERSION >= 3
  STDMETHOD_(UINT, GetGroupConversion)(THIS_ UINT group_index, UINT * unit_index) PURE;
# endif
}; // ELUnitConverter
typedef ELUnitConverter *pELUnitConverter;

# ifndef EL_IGNORE_HELPER_MACROS
#  define ELUnitConverter_InterfaceVersion(p) FUNC(p)->InterfaceVersion(PARAM(p))
#  define ELUnitConverter_AddConversion(p, a, b, c, d, e, f) FUNC(p)->AddConversion(PARAM_(p) a, b, c, d, e, f)
#  define ELUnitConverter_AddGenericConversion(p, a, b, c, d, e) FUNC(p)->AddGenericConversion(PARAM_(p) a, b, c, d, e)
#  define ELUnitConverter_GetGroupIndex(p, a, b) FUNC(p)->GetGroupIndex(PARAM_(p) a, b)
#  define ELUnitConverter_GetGroupName(p, a, b) FUNC(p)->GetGroupName(PARAM_(p) a, b)
#  define ELUnitConverter_GetUnitIndex(p, a, b, c) FUNC(p)->GetUnitIndex(PARAM_(p) a, b, c)
#  define ELUnitConverter_GetUnitName(p, a, b) FUNC(p)->GetUnitName(PARAM_(p) a, b)
#  define ELUnitConverter_GetGroupNameFromUnit(p, a, b) FUNC(p)->GetGroupNameFromUnit(PARAM_(p) a, b)
#  define ELUnitConverter_GetGroupIndexFromUnit(p, a, b) FUNC(p)->GetGroupIndexFromUnit(PARAM_(p) a, b)
#  define ELUnitConverter_SetConversion(p, a, b) FUNC(p)->SetConversion(PARAM_(p) a, b)
#  define ELUnitConverter_ClearConversion(p, a) FUNC(p)->ClearConversion(PARAM_(p) a)
#  define ELUnitConverter_GetAllUnits(p, a, b) FUNC(p)->GetAllUnits(PARAM_(p) a, b)
#  define ELUnitConverter_GetAllCompatibleUnits(p, a, b) FUNC(p)->GetAllCompatibleUnits(PARAM_(p) a, b)
#  define ELUnitConverter_EvaluateConversion(p, a, b, c) FUNC(p)->EvaluateConversion(PARAM_(p) a, b, c)
# if EL_UNIT_CONVERTER_VERSION >= 2
#  define ELUnitConverter_GetConversion(p, a, b) FUNC(p)->GetConversion(PARAM_(p) a, b)
# endif
# if EL_UNIT_CONVERTER_VERSION >= 3
#  define ELUnitConverter_SetGroupConversion(p, a, b) FUNC(p)->SetGroupConversion(PARAM_(p) a, b)
# endif
# if EL_UNIT_CONVERTER_VERSION >= 3
#  define ELUnitConverter_ClearGroupConversion(p, a) FUNC(p)->ClearGroupConversion(PARAM_(p) a)
# endif
# if EL_UNIT_CONVERTER_VERSION >= 3
#  define ELUnitConverter_GetGroupConversion(p, a, b) FUNC(p)->GetGroupConversion(PARAM_(p) a, b)
# endif
# endif

#ifndef EL_DEVICE_VERSION
# define EL_DEVICE_VERSION 1
#endif
# undef INTERFACE
# define INTERFACE ELDevice
DECLARE_INTERFACE(ELDevice) {
  STDMETHOD_(DWORD, InterfaceVersion)(THIS) PURE;
  STDMETHOD_(void, Release)(THIS) PURE;
  STDMETHOD_(DEVICETYPE, Type)(THIS) PURE;
  STDMETHOD_(ELDevice *, Copy)(THIS) PURE;
  STDMETHOD_(const char *, Name)(THIS) PURE;
  STDMETHOD_(void *, Options)(THIS) PURE;
  STDMETHOD_(DWORD, Process)(THIS) PURE;
  STDMETHOD_(BYTE, RawType)(THIS) PURE;
  STDMETHOD_(BOOL, Available)(THIS) PURE;
  STDMETHOD_(BOOL, LocallyOwned)(THIS) PURE;
}; // ELDevice
typedef ELDevice *pELDevice;

# ifndef EL_IGNORE_HELPER_MACROS
#  define ELDevice_InterfaceVersion(p) FUNC(p)->InterfaceVersion(PARAM(p))
#  define ELDevice_Release(p) FUNC(p)->Release(PARAM(p))
#  define ELDevice_Type(p) FUNC(p)->Type(PARAM(p))
#  define ELDevice_Copy(p) FUNC(p)->Copy(PARAM(p))
#  define ELDevice_Name(p) FUNC(p)->Name(PARAM(p))
#  define ELDevice_Options(p) FUNC(p)->Options(PARAM(p))
#  define ELDevice_Process(p) FUNC(p)->Process(PARAM(p))
#  define ELDevice_RawType(p) FUNC(p)->RawType(PARAM(p))
#  define ELDevice_Available(p) FUNC(p)->Available(PARAM(p))
#  define ELDevice_LocallyOwned(p) FUNC(p)->LocallyOwned(PARAM(p))
# endif

#ifndef EL_DEVICE_LIST_VERSION
# define EL_DEVICE_LIST_VERSION 1
#endif
# undef INTERFACE
# define INTERFACE ELDeviceList
DECLARE_INTERFACE(ELDeviceList) {
  STDMETHOD_(DWORD, InterfaceVersion)(THIS) PURE;
  STDMETHOD_(void, Release)(THIS) PURE;
  STDMETHOD_(DEVICETYPE, Type)(THIS) PURE;
  STDMETHOD_(UINT, Count)(THIS) PURE;
  STDMETHOD_(pELDevice, Device)(THIS_ UINT index) PURE;
  STDMETHOD_(void, Clear)(THIS) PURE;
}; // ELDeviceList
typedef ELDeviceList *pELDeviceList;

# ifndef EL_IGNORE_HELPER_MACROS
#  define ELDeviceList_InterfaceVersion(p) FUNC(p)->InterfaceVersion(PARAM(p))
#  define ELDeviceList_Release(p) FUNC(p)->Release(PARAM(p))
#  define ELDeviceList_Type(p) FUNC(p)->Type(PARAM(p))
#  define ELDeviceList_Count(p) FUNC(p)->Count(PARAM(p))
#  define ELDeviceList_Device(p, a) FUNC(p)->Device(PARAM_(p) a)
#  define ELDeviceList_Clear(p) FUNC(p)->Clear(PARAM(p))
# endif

#ifndef EL_RAW_LOG_DATA_VERSION
# define EL_RAW_LOG_DATA_VERSION 1
#endif
// This will hold a copy of raw log data.
# undef INTERFACE
# define INTERFACE ELRawLogData
DECLARE_INTERFACE(ELRawLogData) {
  STDMETHOD_(DWORD, InterfaceVersion)(THIS) PURE;
  STDMETHOD_(void, Release)(THIS) PURE;
  STDMETHOD_(DWORD, Count)(THIS) PURE;
  STDMETHOD_(UINT, Sample)(THIS_ DWORD index, float * data, LOGTIMESTAMP * timestamp) PURE;
  STDMETHOD_(float *, DataArray)(THIS) PURE;
  STDMETHOD_(LOGTIMESTAMP *, TimestampArray)(THIS) PURE;
}; // ELRawLogData
typedef ELRawLogData *pELRawLogData;

# ifndef EL_IGNORE_HELPER_MACROS
#  define ELRawLogData_InterfaceVersion(p) FUNC(p)->InterfaceVersion(PARAM(p))
#  define ELRawLogData_Release(p) FUNC(p)->Release(PARAM(p))
#  define ELRawLogData_Count(p) FUNC(p)->Count(PARAM(p))
#  define ELRawLogData_Sample(p, a, b, c) FUNC(p)->Sample(PARAM_(p) a, b, c)
#  define ELRawLogData_DataArray(p) FUNC(p)->DataArray(PARAM(p))
#  define ELRawLogData_TimestampArray(p) FUNC(p)->TimestampArray(PARAM(p))
# endif

#ifndef EL_HOST_VERSION
# define EL_HOST_VERSION 5
#endif
# undef INTERFACE
# define INTERFACE ELHost
DECLARE_INTERFACE(ELHost) {
  STDMETHOD_(DWORD, InterfaceVersion)(THIS) PURE;
  STDMETHOD_(const pELVersions, Versions)(THIS) PURE;
  STDMETHOD_(pELTarget, Target)(THIS_ UINT target_enumerator) PURE;
// Modeler
//   Replaces ELFullTarget.  Retrieves the modeler used for the given target.
  STDMETHOD_(pELModeler, Modeler)(THIS_ UINT target_enumerator) PURE;
  STDMETHOD_(pELLayout, Layout)(THIS) PURE;
  STDMETHOD_(pELDialogs, Dialogs)(THIS) PURE;
  STDMETHOD_(const pELLogInfo, LogInfo)(THIS) PURE;
  STDMETHOD_(const pELHostInfo, HostInfo)(THIS) PURE;
  STDMETHOD_(UINT, OpenConfiguration)(THIS_ const char * file, pELConfiguration * out_config) PURE;
  STDMETHOD_(UINT, CloseConfiguration)(THIS_ pELConfiguration * config) PURE;
  STDMETHOD_(HWND, GetHWND)(THIS) PURE;
  STDMETHOD_(UINT, RegisterHotkey)(THIS_ const char * sequence, UINT menu_id) PURE;
  STDMETHOD_(UINT, RegisterHotkeyWithFunction)(THIS_ const char * sequence, void (*callback)(void)) PURE;
  STDMETHOD_(BOOL, HandleKeyPressed)(THIS_ MSG * pMsg) PURE;
  STDMETHOD_(pEL3DData, D3DData)(THIS) PURE;
  STDMETHOD_(void, D3DDeviceLost)(THIS) PURE;
  STDMETHOD_(UINT, LoadD3DMesh)(THIS_ const char * file, LPD3DXMESH * out_mesh, D3DMATERIAL9 ** out_materials, UINT * out_material_count) PURE;
  STDMETHOD_(UINT, LoadD3DTexture)(THIS_ const char * file, LPDIRECT3DTEXTURE9 * out_texture) PURE;
  STDMETHOD_(UINT, CreateD3DTextMesh)(THIS_ const char * text, LPD3DXMESH * out_mesh) PURE;
  STDMETHOD_(UINT, RegisterChannels)(THIS_ pELChannelGroup group) PURE;
  STDMETHOD_(UINT, UnregisterChannels)(THIS_ pELChannelGroup group, BOOL free) PURE;
  STDMETHOD_(UINT, RegisterGroup)(THIS_ pELChannelGroup group) PURE;
  STDMETHOD_(UINT, UnregisterGroup)(THIS_ pELChannelGroup group) PURE;
  STDMETHOD_(const char *, OptionChanged)(THIS_ const char * option_name) PURE;
  STDMETHOD_(UINT, OptionValue)(THIS_ const char * option_name, pELString * out_value) PURE;
  STDMETHOD_(UINT, StartLogging)(THIS_ const char * file) PURE;
  STDMETHOD_(UINT, StopLogging)(THIS_ pELString * out_file) PURE;
  STDMETHOD_(UINT, LogChannels)(THIS_ pELChannelInfo * channels, UINT count) PURE;
  STDMETHOD_(UINT, SetLogDisplayRange)(THIS_ LOGTIMESTAMP start_time, LOGTIMESTAMP end_time) PURE;
  STDMETHOD_(UINT, SetLogCursor)(THIS_ LOGTIMESTAMP time) PURE;
  STDMETHOD_(BOOL, HandleSystemMenu)(THIS_ pELControl control, UINT id, pELChannelInfo channel) PURE;
  STDMETHOD_(UINT, SetChannels)(THIS_ pELChannelGroup group, pELString * channel_names, UINT names_count) PURE;
  STDMETHOD_(UINT, ModifyChannel)(THIS_ pELChannelInfo channel, INFOSELECT which) PURE;
  STDMETHOD_(UINT, ExpandTable)(THIS_ pELChannelInfo channel, float at, BOOL row) PURE;
  STDMETHOD_(UINT, ShrinkTable)(THIS_ pELChannelInfo channel, UINT at, BOOL row) PURE;
  STDMETHOD_(UINT, ApplyMathExpression)(THIS_ pELChannelInfo channel, INFOSELECT which, const char * expression, const RECT * selection) PURE;
  STDMETHOD_(UINT, WriteChannel)(THIS_ pELChannelInfo channel, float value, BOOL initial) PURE;
  STDMETHOD_(UINT, SetSelection)(THIS_ pELChannelInfo channel, const RECT * selection) PURE;
  STDMETHOD_(UINT, SetFollowECU)(THIS_ pELChannelInfo channel, BOOL follow) PURE;
  STDMETHOD_(pELChannelInfo, GetChannelInfo)(THIS_ const char * channel_name) PURE;
  STDMETHOD_(UINT, AllocateChannelInfo)(THIS_ const char * channel_name, pELChannelInfo * out_channel, BOOL shared) PURE;
  STDMETHOD_(void, FreeChannelInfo)(THIS_ pELChannelInfo * channel) PURE;
  STDMETHOD_(void, ErrorMessage)(THIS_ const char * message) PURE;
  STDMETHOD_(UINT, AddVirtualChannel)(THIS_ VIRTUALCHANNELTYPE type, const char * name, pELStringArray strings, pELStringArray inputs) PURE;
# if EL_HOST_VERSION >= 2
  STDMETHOD_(UINT, ReRegisterChannels)(THIS_ pELChannelGroup group) PURE;
# endif
# if EL_HOST_VERSION >= 2
  STDMETHOD_(UINT, SetChannelsEx)(THIS_ pELChannelGroup group, pELStringArray channel_names) PURE;
# endif
# if EL_HOST_VERSION >= 2
  STDMETHOD_(UINT, ModifyChannelEx)(THIS_ pELChannelInfo channel, pELCellInfo cells, INFOSELECT which) PURE;
# endif
# if EL_HOST_VERSION >= 2
  STDMETHOD_(pELUnitConverter, UnitConverter)(THIS) PURE;
# endif
# if EL_HOST_VERSION >= 2
  STDMETHOD_(UINT, AdjustUnitInName)(THIS_ pELChannelInfo channel, INFOSELECT which, pELString * out_string) PURE;
# endif
# if EL_HOST_VERSION >= 3
  STDMETHOD_(UINT, ClearVirtualChannels)(THIS) PURE;
# endif
# if EL_HOST_VERSION >= 3
  STDMETHOD_(UINT, RegisterChannelsWithName)(THIS_ pELChannelGroup group, const char * channel_name) PURE;
# endif
# if EL_HOST_VERSION >= 3
  STDMETHOD_(UINT, UnregisterChannelsWithName)(THIS_ pELChannelGroup group, const char * channel_name, BOOL clear) PURE;
# endif
# if EL_HOST_VERSION >= 4
  STDMETHOD_(UINT, NotifyChannelAdded)(THIS_ const char * name, WORD channel, pELTarget target) PURE;
# endif
# if EL_HOST_VERSION >= 4
  STDMETHOD_(UINT, NotifyChannelRemoved)(THIS_ const char * name, WORD channel, pELTarget target) PURE;
# endif
# if EL_HOST_VERSION >= 4
  STDMETHOD_(UINT, NotifyChannelRenamed)(THIS_ const char * old_name, const char * new_name, WORD channel, pELTarget target) PURE;
# endif
// RawLogData
//   This will retrieve information about the given channel.  The data pointers will be to all the data in the given range.
# if EL_HOST_VERSION >= 5
  STDMETHOD_(UINT, RawLogData)(THIS_ const char * channel, LOGTIMESTAMP from, LOGTIMESTAMP to, pELRawLogConstData data) PURE;
# endif
// RawLogDataCopy
//   This will obtain a copy of the given channels log information. 
# if EL_HOST_VERSION >= 5
  STDMETHOD_(UINT, RawLogDataCopy)(THIS_ const char * channel, LOGTIMESTAMP from, LOGTIMESTAMP to, void * context, BOOL (*callback)(void *, pELRawLogData)) PURE;
# endif
}; // ELHost
typedef ELHost *pELHost;

# ifndef EL_IGNORE_HELPER_MACROS
#  define ELHost_InterfaceVersion(p) FUNC(p)->InterfaceVersion(PARAM(p))
#  define ELHost_Versions(p) FUNC(p)->Versions(PARAM(p))
#  define ELHost_Target(p, a) FUNC(p)->Target(PARAM_(p) a)
#  define ELHost_Modeler(p, a) FUNC(p)->Modeler(PARAM_(p) a)
#  define ELHost_Layout(p) FUNC(p)->Layout(PARAM(p))
#  define ELHost_Dialogs(p) FUNC(p)->Dialogs(PARAM(p))
#  define ELHost_LogInfo(p) FUNC(p)->LogInfo(PARAM(p))
#  define ELHost_HostInfo(p) FUNC(p)->HostInfo(PARAM(p))
#  define ELHost_OpenConfiguration(p, a, b) FUNC(p)->OpenConfiguration(PARAM_(p) a, b)
#  define ELHost_CloseConfiguration(p, a) FUNC(p)->CloseConfiguration(PARAM_(p) a)
#  define ELHost_GetHWND(p) FUNC(p)->GetHWND(PARAM(p))
#  define ELHost_RegisterHotkey(p, a, b) FUNC(p)->RegisterHotkey(PARAM_(p) a, b)
#  define ELHost_RegisterHotkeyWithFunction(p, a, b) FUNC(p)->RegisterHotkeyWithFunction(PARAM_(p) a, b)
#  define ELHost_HandleKeyPressed(p, a) FUNC(p)->HandleKeyPressed(PARAM_(p) a)
#  define ELHost_D3DData(p) FUNC(p)->D3DData(PARAM(p))
#  define ELHost_D3DDeviceLost(p) FUNC(p)->D3DDeviceLost(PARAM(p))
#  define ELHost_LoadD3DMesh(p, a, b, c, d) FUNC(p)->LoadD3DMesh(PARAM_(p) a, b, c, d)
#  define ELHost_LoadD3DTexture(p, a, b) FUNC(p)->LoadD3DTexture(PARAM_(p) a, b)
#  define ELHost_CreateD3DTextMesh(p, a, b) FUNC(p)->CreateD3DTextMesh(PARAM_(p) a, b)
#  define ELHost_RegisterChannels(p, a) FUNC(p)->RegisterChannels(PARAM_(p) a)
#  define ELHost_UnregisterChannels(p, a, b) FUNC(p)->UnregisterChannels(PARAM_(p) a, b)
#  define ELHost_RegisterGroup(p, a) FUNC(p)->RegisterGroup(PARAM_(p) a)
#  define ELHost_UnregisterGroup(p, a) FUNC(p)->UnregisterGroup(PARAM_(p) a)
#  define ELHost_OptionChanged(p, a) FUNC(p)->OptionChanged(PARAM_(p) a)
#  define ELHost_OptionValue(p, a, b) FUNC(p)->OptionValue(PARAM_(p) a, b)
#  define ELHost_StartLogging(p, a) FUNC(p)->StartLogging(PARAM_(p) a)
#  define ELHost_StopLogging(p, a) FUNC(p)->StopLogging(PARAM_(p) a)
#  define ELHost_LogChannels(p, a, b) FUNC(p)->LogChannels(PARAM_(p) a, b)
#  define ELHost_SetLogDisplayRange(p, a, b) FUNC(p)->SetLogDisplayRange(PARAM_(p) a, b)
#  define ELHost_SetLogCursor(p, a) FUNC(p)->SetLogCursor(PARAM_(p) a)
#  define ELHost_HandleSystemMenu(p, a, b, c) FUNC(p)->HandleSystemMenu(PARAM_(p) a, b, c)
#  define ELHost_SetChannels(p, a, b, c) FUNC(p)->SetChannels(PARAM_(p) a, b, c)
#  define ELHost_ModifyChannel(p, a, b) FUNC(p)->ModifyChannel(PARAM_(p) a, b)
#  define ELHost_ExpandTable(p, a, b, c) FUNC(p)->ExpandTable(PARAM_(p) a, b, c)
#  define ELHost_ShrinkTable(p, a, b, c) FUNC(p)->ShrinkTable(PARAM_(p) a, b, c)
#  define ELHost_ApplyMathExpression(p, a, b, c, d) FUNC(p)->ApplyMathExpression(PARAM_(p) a, b, c, d)
#  define ELHost_WriteChannel(p, a, b, c) FUNC(p)->WriteChannel(PARAM_(p) a, b, c)
#  define ELHost_SetSelection(p, a, b) FUNC(p)->SetSelection(PARAM_(p) a, b)
#  define ELHost_SetFollowECU(p, a, b) FUNC(p)->SetFollowECU(PARAM_(p) a, b)
#  define ELHost_GetChannelInfo(p, a) FUNC(p)->GetChannelInfo(PARAM_(p) a)
#  define ELHost_AllocateChannelInfo(p, a, b, c) FUNC(p)->AllocateChannelInfo(PARAM_(p) a, b, c)
#  define ELHost_FreeChannelInfo(p, a) FUNC(p)->FreeChannelInfo(PARAM_(p) a)
#  define ELHost_ErrorMessage(p, a) FUNC(p)->ErrorMessage(PARAM_(p) a)
#  define ELHost_AddVirtualChannel(p, a, b, c, d) FUNC(p)->AddVirtualChannel(PARAM_(p) a, b, c, d)
# if EL_HOST_VERSION >= 2
#  define ELHost_ReRegisterChannels(p, a) FUNC(p)->ReRegisterChannels(PARAM_(p) a)
# endif
# if EL_HOST_VERSION >= 2
#  define ELHost_SetChannelsEx(p, a, b) FUNC(p)->SetChannelsEx(PARAM_(p) a, b)
# endif
# if EL_HOST_VERSION >= 2
#  define ELHost_ModifyChannelEx(p, a, b, c) FUNC(p)->ModifyChannelEx(PARAM_(p) a, b, c)
# endif
# if EL_HOST_VERSION >= 2
#  define ELHost_UnitConverter(p) FUNC(p)->UnitConverter(PARAM(p))
# endif
# if EL_HOST_VERSION >= 2
#  define ELHost_AdjustUnitInName(p, a, b, c) FUNC(p)->AdjustUnitInName(PARAM_(p) a, b, c)
# endif
# if EL_HOST_VERSION >= 3
#  define ELHost_ClearVirtualChannels(p) FUNC(p)->ClearVirtualChannels(PARAM(p))
# endif
# if EL_HOST_VERSION >= 3
#  define ELHost_RegisterChannelsWithName(p, a, b) FUNC(p)->RegisterChannelsWithName(PARAM_(p) a, b)
# endif
# if EL_HOST_VERSION >= 3
#  define ELHost_UnregisterChannelsWithName(p, a, b, c) FUNC(p)->UnregisterChannelsWithName(PARAM_(p) a, b, c)
# endif
# if EL_HOST_VERSION >= 4
#  define ELHost_NotifyChannelAdded(p, a, b, c) FUNC(p)->NotifyChannelAdded(PARAM_(p) a, b, c)
# endif
# if EL_HOST_VERSION >= 4
#  define ELHost_NotifyChannelRemoved(p, a, b, c) FUNC(p)->NotifyChannelRemoved(PARAM_(p) a, b, c)
# endif
# if EL_HOST_VERSION >= 4
#  define ELHost_NotifyChannelRenamed(p, a, b, c, d) FUNC(p)->NotifyChannelRenamed(PARAM_(p) a, b, c, d)
# endif
# if EL_HOST_VERSION >= 5
#  define ELHost_RawLogData(p, a, b, c, d) FUNC(p)->RawLogData(PARAM_(p) a, b, c, d)
# endif
# if EL_HOST_VERSION >= 5
#  define ELHost_RawLogDataCopy(p, a, b, c, d, e) FUNC(p)->RawLogDataCopy(PARAM_(p) a, b, c, d, e)
# endif
# endif

#ifndef EL_BUS_OVERRIDE_VERSION
# define EL_BUS_OVERRIDE_VERSION 1
#endif
# undef INTERFACE
# define INTERFACE ELBusOverride
DECLARE_INTERFACE(ELBusOverride) {
  STDMETHOD_(DWORD, InterfaceVersion)(THIS) PURE;
  STDMETHOD_(pELBusChannel, Channel)(THIS) PURE;
  STDMETHOD_(void, SetChannel)(THIS_ pELBusChannel channel) PURE;
  STDMETHOD_(pELBusDirection, Direction)(THIS) PURE;
  STDMETHOD_(void, SetDirection)(THIS_ pELBusDirection direction) PURE;
  STDMETHOD_(pELBusTxMode, ModeTx)(THIS) PURE;
  STDMETHOD_(void, SetModeTx)(THIS_ pELBusTxMode direction) PURE;
}; // ELBusOverride
typedef ELBusOverride *pELBusOverride;

# ifndef EL_IGNORE_HELPER_MACROS
#  define ELBusOverride_InterfaceVersion(p) FUNC(p)->InterfaceVersion(PARAM(p))
#  define ELBusOverride_Channel(p) FUNC(p)->Channel(PARAM(p))
#  define ELBusOverride_SetChannel(p, a) FUNC(p)->SetChannel(PARAM_(p) a)
#  define ELBusOverride_Direction(p) FUNC(p)->Direction(PARAM(p))
#  define ELBusOverride_SetDirection(p, a) FUNC(p)->SetDirection(PARAM_(p) a)
#  define ELBusOverride_ModeTx(p) FUNC(p)->ModeTx(PARAM(p))
#  define ELBusOverride_SetModeTx(p, a) FUNC(p)->SetModeTx(PARAM_(p) a)
# endif

#ifndef EL_LATCH_VERSION
# define EL_LATCH_VERSION 1
#endif
# undef INTERFACE
# define INTERFACE ELLatch
DECLARE_INTERFACE(ELLatch) {
  STDMETHOD_(DWORD, InterfaceVersion)(THIS) PURE;
  STDMETHOD_(pELLatchEdge, Edge)(THIS) PURE;
  STDMETHOD_(void, SetEdge)(THIS_ pELLatchEdge edge) PURE;
  STDMETHOD_(pELLatchStartState, StartState)(THIS) PURE;
  STDMETHOD_(void, SetStartState)(THIS_ pELLatchStartState state) PURE;
}; // ELLatch
typedef ELLatch *pELLatch;

# ifndef EL_IGNORE_HELPER_MACROS
#  define ELLatch_InterfaceVersion(p) FUNC(p)->InterfaceVersion(PARAM(p))
#  define ELLatch_Edge(p) FUNC(p)->Edge(PARAM(p))
#  define ELLatch_SetEdge(p, a) FUNC(p)->SetEdge(PARAM_(p) a)
#  define ELLatch_StartState(p) FUNC(p)->StartState(PARAM(p))
#  define ELLatch_SetStartState(p, a) FUNC(p)->SetStartState(PARAM_(p) a)
# endif

#ifndef EL_EXTERN_VERSION
# define EL_EXTERN_VERSION 1
#endif
# undef INTERFACE
# define INTERFACE ELExtern
DECLARE_INTERFACE(ELExtern) {
  STDMETHOD_(DWORD, InterfaceVersion)(THIS) PURE;
  STDMETHOD_(void, Release)(THIS) PURE;
  STDMETHOD_(const char *, Name)(THIS) PURE;
  STDMETHOD_(UINT, Index)(THIS) PURE;
}; // ELExtern
typedef ELExtern *pELExtern;

# ifndef EL_IGNORE_HELPER_MACROS
#  define ELExtern_InterfaceVersion(p) FUNC(p)->InterfaceVersion(PARAM(p))
#  define ELExtern_Release(p) FUNC(p)->Release(PARAM(p))
#  define ELExtern_Name(p) FUNC(p)->Name(PARAM(p))
#  define ELExtern_Index(p) FUNC(p)->Index(PARAM(p))
# endif

#ifndef EL_EXTERN_LIST_VERSION
# define EL_EXTERN_LIST_VERSION 1
#endif
# undef INTERFACE
# define INTERFACE ELExternList
DECLARE_INTERFACE(ELExternList) {
  STDMETHOD_(DWORD, InterfaceVersion)(THIS) PURE;
  STDMETHOD_(UINT, Count)(THIS) PURE;
  STDMETHOD_(pELExtern, Extern)(THIS_ UINT index) PURE;
}; // ELExternList
typedef ELExternList *pELExternList;

# ifndef EL_IGNORE_HELPER_MACROS
#  define ELExternList_InterfaceVersion(p) FUNC(p)->InterfaceVersion(PARAM(p))
#  define ELExternList_Count(p) FUNC(p)->Count(PARAM(p))
#  define ELExternList_Extern(p, a) FUNC(p)->Extern(PARAM_(p) a)
# endif

#ifndef EL_ITEM_INPUT_VERSION
# define EL_ITEM_INPUT_VERSION 1
#endif
# undef INTERFACE
# define INTERFACE ELItemInput
DECLARE_INTERFACE(ELItemInput) {
  STDMETHOD_(DWORD, InterfaceVersion)(THIS) PURE;
  STDMETHOD_(INPUTTYPE, Type)(THIS) PURE;
// Channel
//   Returns a channel number if input is self or an item.  Returns an index if an extern.
  STDMETHOD_(WORD, Channel)(THIS) PURE;
// Value
//   Only returns sane value if type is a constant.
  STDMETHOD_(float, Value)(THIS) PURE;
}; // ELItemInput
typedef ELItemInput *pELItemInput;

# ifndef EL_IGNORE_HELPER_MACROS
#  define ELItemInput_InterfaceVersion(p) FUNC(p)->InterfaceVersion(PARAM(p))
#  define ELItemInput_Type(p) FUNC(p)->Type(PARAM(p))
#  define ELItemInput_Channel(p) FUNC(p)->Channel(PARAM(p))
#  define ELItemInput_Value(p) FUNC(p)->Value(PARAM(p))
# endif

#ifndef EL_ITEM_INPUTS_VERSION
# define EL_ITEM_INPUTS_VERSION 1
#endif
# undef INTERFACE
# define INTERFACE ELItemInputs
DECLARE_INTERFACE(ELItemInputs) {
  STDMETHOD_(DWORD, InterfaceVersion)(THIS) PURE;
  STDMETHOD_(UINT, Count)(THIS) PURE;
  STDMETHOD_(pELItemInput, Input)(THIS_ UINT index) PURE;
  STDMETHOD_(void, Clear)(THIS) PURE;
// Add
//   Add for self, item, or extern.  channel is expected to be an index if adding an extern.
  STDMETHOD_(UINT, Add)(THIS_ INPUTTYPE type, UINT index, WORD channel) PURE;
  STDMETHOD_(UINT, AddConstant)(THIS_ UINT index, float value) PURE;
  STDMETHOD_(void, Remove)(THIS_ UINT index) PURE;
  STDMETHOD_(UINT, Swap)(THIS_ UINT first, UINT second) PURE;
}; // ELItemInputs
typedef ELItemInputs *pELItemInputs;

# ifndef EL_IGNORE_HELPER_MACROS
#  define ELItemInputs_InterfaceVersion(p) FUNC(p)->InterfaceVersion(PARAM(p))
#  define ELItemInputs_Count(p) FUNC(p)->Count(PARAM(p))
#  define ELItemInputs_Input(p, a) FUNC(p)->Input(PARAM_(p) a)
#  define ELItemInputs_Clear(p) FUNC(p)->Clear(PARAM(p))
#  define ELItemInputs_Add(p, a, b, c) FUNC(p)->Add(PARAM_(p) a, b, c)
#  define ELItemInputs_AddConstant(p, a, b) FUNC(p)->AddConstant(PARAM_(p) a, b)
#  define ELItemInputs_Remove(p, a) FUNC(p)->Remove(PARAM_(p) a)
#  define ELItemInputs_Swap(p, a, b) FUNC(p)->Swap(PARAM_(p) a, b)
# endif

#ifndef EL_ITEM_THREAD_CONTROL_VERSION
# define EL_ITEM_THREAD_CONTROL_VERSION 1
#endif
# undef INTERFACE
# define INTERFACE ELItemThreadControl
DECLARE_INTERFACE(ELItemThreadControl) {
  STDMETHOD_(DWORD, InterfaceVersion)(THIS) PURE;
  STDMETHOD_(void, IdRange)(THIS_ UINT * minimum, UINT * maximum) PURE;
  STDMETHOD_(UINT, Id)(THIS) PURE;
  STDMETHOD_(UINT, SetId)(THIS_ UINT id) PURE;
  STDMETHOD_(void, IterationRange)(THIS_ UINT * minimum, UINT * maximum) PURE;
  STDMETHOD_(UINT, Iteration)(THIS) PURE;
  STDMETHOD_(UINT, SetIteration)(THIS_ UINT iteration) PURE;
  STDMETHOD_(void, PriorityRange)(THIS_ UINT * minimum, UINT * maximum) PURE;
  STDMETHOD_(UINT, Priority)(THIS) PURE;
  STDMETHOD_(UINT, SetPriority)(THIS_ UINT priority) PURE;
}; // ELItemThreadControl
typedef ELItemThreadControl *pELItemThreadControl;

# ifndef EL_IGNORE_HELPER_MACROS
#  define ELItemThreadControl_InterfaceVersion(p) FUNC(p)->InterfaceVersion(PARAM(p))
#  define ELItemThreadControl_IdRange(p, a, b) FUNC(p)->IdRange(PARAM_(p) a, b)
#  define ELItemThreadControl_Id(p) FUNC(p)->Id(PARAM(p))
#  define ELItemThreadControl_SetId(p, a) FUNC(p)->SetId(PARAM_(p) a)
#  define ELItemThreadControl_IterationRange(p, a, b) FUNC(p)->IterationRange(PARAM_(p) a, b)
#  define ELItemThreadControl_Iteration(p) FUNC(p)->Iteration(PARAM(p))
#  define ELItemThreadControl_SetIteration(p, a) FUNC(p)->SetIteration(PARAM_(p) a)
#  define ELItemThreadControl_PriorityRange(p, a, b) FUNC(p)->PriorityRange(PARAM_(p) a, b)
#  define ELItemThreadControl_Priority(p) FUNC(p)->Priority(PARAM(p))
#  define ELItemThreadControl_SetPriority(p, a) FUNC(p)->SetPriority(PARAM_(p) a)
# endif

#ifndef EL_ITEM_HEADER_VERSION
# define EL_ITEM_HEADER_VERSION 1
#endif
# undef INTERFACE
# define INTERFACE ELItemHeader
DECLARE_INTERFACE(ELItemHeader) {
  STDMETHOD_(float, OutputValue)(THIS) PURE;
  STDMETHOD_(float, InitialValue)(THIS) PURE;
  STDMETHOD_(void, SetInitialValue)(THIS_ float value) PURE;
  STDMETHOD_(float, TestValue)(THIS) PURE;
  STDMETHOD_(void, SetTestValue)(THIS_ float value) PURE;
  STDMETHOD_(float, LowerClamp)(THIS) PURE;
  STDMETHOD_(void, SetLowerClamp)(THIS_ float value) PURE;
  STDMETHOD_(float, UpperClamp)(THIS) PURE;
  STDMETHOD_(void, SetUpperClamp)(THIS_ float value) PURE;
  STDMETHOD_(pELItemType, Type)(THIS) PURE;
  STDMETHOD_(WORD, Channel)(THIS) PURE;
  STDMETHOD_(UINT, SetChannel)(THIS_ WORD value) PURE;
  STDMETHOD_(const char *, Name)(THIS) PURE;
  STDMETHOD_(UINT, SetName)(THIS_ const char * name) PURE;
  STDMETHOD_(void, InputRange)(THIS_ WORD * minimum, WORD * maximum) PURE;
  STDMETHOD_(pELItemInputs, Inputs)(THIS) PURE;
  STDMETHOD_(BOOL, Flag)(THIS_ ITEMFLAG flag) PURE;
  STDMETHOD_(void, SetFlag)(THIS_ ITEMFLAG flag, BOOL on) PURE;
  STDMETHOD_(BOOL, ModifyFlag)(THIS_ ITEMMODFLAG flag) PURE;
  STDMETHOD_(void, SetModifyFlag)(THIS_ ITEMMODFLAG flag, BOOL on) PURE;
  STDMETHOD_(pELItemThreadControl, ThreadControl)(THIS) PURE;
}; // ELItemHeader
typedef ELItemHeader *pELItemHeader;

# ifndef EL_IGNORE_HELPER_MACROS
#  define ELItemHeader_OutputValue(p) FUNC(p)->OutputValue(PARAM(p))
#  define ELItemHeader_InitialValue(p) FUNC(p)->InitialValue(PARAM(p))
#  define ELItemHeader_SetInitialValue(p, a) FUNC(p)->SetInitialValue(PARAM_(p) a)
#  define ELItemHeader_TestValue(p) FUNC(p)->TestValue(PARAM(p))
#  define ELItemHeader_SetTestValue(p, a) FUNC(p)->SetTestValue(PARAM_(p) a)
#  define ELItemHeader_LowerClamp(p) FUNC(p)->LowerClamp(PARAM(p))
#  define ELItemHeader_SetLowerClamp(p, a) FUNC(p)->SetLowerClamp(PARAM_(p) a)
#  define ELItemHeader_UpperClamp(p) FUNC(p)->UpperClamp(PARAM(p))
#  define ELItemHeader_SetUpperClamp(p, a) FUNC(p)->SetUpperClamp(PARAM_(p) a)
#  define ELItemHeader_Type(p) FUNC(p)->Type(PARAM(p))
#  define ELItemHeader_Channel(p) FUNC(p)->Channel(PARAM(p))
#  define ELItemHeader_SetChannel(p, a) FUNC(p)->SetChannel(PARAM_(p) a)
#  define ELItemHeader_Name(p) FUNC(p)->Name(PARAM(p))
#  define ELItemHeader_SetName(p, a) FUNC(p)->SetName(PARAM_(p) a)
#  define ELItemHeader_InputRange(p, a, b) FUNC(p)->InputRange(PARAM_(p) a, b)
#  define ELItemHeader_Inputs(p) FUNC(p)->Inputs(PARAM(p))
#  define ELItemHeader_Flag(p, a) FUNC(p)->Flag(PARAM_(p) a)
#  define ELItemHeader_SetFlag(p, a, b) FUNC(p)->SetFlag(PARAM_(p) a, b)
#  define ELItemHeader_ModifyFlag(p, a) FUNC(p)->ModifyFlag(PARAM_(p) a)
#  define ELItemHeader_SetModifyFlag(p, a, b) FUNC(p)->SetModifyFlag(PARAM_(p) a, b)
#  define ELItemHeader_ThreadControl(p) FUNC(p)->ThreadControl(PARAM(p))
# endif

#ifndef EL_ITEM_VERSION
# define EL_ITEM_VERSION 1
#endif
# undef INTERFACE
# define INTERFACE ELItem
DECLARE_INTERFACE(ELItem) {
  STDMETHOD_(DWORD, InterfaceVersion)(THIS) PURE;
  STDMETHOD_(void, Release)(THIS) PURE;
  STDMETHOD_(pELItemType, Type)(THIS) PURE;
  STDMETHOD_(WORD, Channel)(THIS) PURE;
  STDMETHOD_(const char *, Name)(THIS) PURE;
  STDMETHOD_(pELItemHeader, Header)(THIS) PURE;
}; // ELItem
typedef ELItem *pELItem;

# ifndef EL_IGNORE_HELPER_MACROS
#  define ELItem_InterfaceVersion(p) FUNC(p)->InterfaceVersion(PARAM(p))
#  define ELItem_Release(p) FUNC(p)->Release(PARAM(p))
#  define ELItem_Type(p) FUNC(p)->Type(PARAM(p))
#  define ELItem_Channel(p) FUNC(p)->Channel(PARAM(p))
#  define ELItem_Name(p) FUNC(p)->Name(PARAM(p))
#  define ELItem_Header(p) FUNC(p)->Header(PARAM(p))
# endif

#ifndef EL_ITEM_LIST_VERSION
# define EL_ITEM_LIST_VERSION 2
#endif
// Item lists are attached to the ELTarget that produced the list.  Thus allowing for refreshing without knowing the target.
# undef INTERFACE
# define INTERFACE ELItemList
DECLARE_INTERFACE(ELItemList) {
  STDMETHOD_(DWORD, InterfaceVersion)(THIS) PURE;
// Release
//   As the list may change over time, it must be released when no longer needed.
  STDMETHOD_(void, Release)(THIS) PURE;
  STDMETHOD_(UINT, Count)(THIS) PURE;
  STDMETHOD_(pELItem, Item)(THIS_ UINT index) PURE;
# if EL_ITEM_LIST_VERSION >= 2
  STDMETHOD_(ITEMFILTER, Filter)(THIS) PURE;
# endif
// Refresh
//   Refreshes the list with currently set filter.
# if EL_ITEM_LIST_VERSION >= 2
  STDMETHOD_(UINT, Refresh)(THIS) PURE;
# endif
// RefreshWithFilter
//   Sets the filter then refreshes the list.
# if EL_ITEM_LIST_VERSION >= 2
  STDMETHOD_(UINT, RefreshWithFilter)(THIS_ ITEMFILTER filter) PURE;
# endif
}; // ELItemList
typedef ELItemList *pELItemList;

# ifndef EL_IGNORE_HELPER_MACROS
#  define ELItemList_InterfaceVersion(p) FUNC(p)->InterfaceVersion(PARAM(p))
#  define ELItemList_Release(p) FUNC(p)->Release(PARAM(p))
#  define ELItemList_Count(p) FUNC(p)->Count(PARAM(p))
#  define ELItemList_Item(p, a) FUNC(p)->Item(PARAM_(p) a)
# if EL_ITEM_LIST_VERSION >= 2
#  define ELItemList_Filter(p) FUNC(p)->Filter(PARAM(p))
# endif
# if EL_ITEM_LIST_VERSION >= 2
#  define ELItemList_Refresh(p) FUNC(p)->Refresh(PARAM(p))
# endif
# if EL_ITEM_LIST_VERSION >= 2
#  define ELItemList_RefreshWithFilter(p, a) FUNC(p)->RefreshWithFilter(PARAM_(p) a)
# endif
# endif

#ifndef EL_NOOPERATION_ITEM_VERSION
# define EL_NOOPERATION_ITEM_VERSION 1
#endif
# undef INTERFACE
# define INTERFACE ELNoOperationItem
DECLARE_INTERFACE_(ELNoOperationItem, ELItem) {
  STDMETHOD_(DWORD, InterfaceVersion)(THIS) PURE;
  STDMETHOD_(void, Release)(THIS) PURE;
  STDMETHOD_(pELItemType, Type)(THIS) PURE;
  STDMETHOD_(WORD, Channel)(THIS) PURE;
  STDMETHOD_(const char *, Name)(THIS) PURE;
  STDMETHOD_(pELItemHeader, Header)(THIS) PURE;
}; // ELNoOperationItem
typedef ELNoOperationItem *pELNoOperationItem;

#ifndef EL_CAN_PACKET_ENTRY_VERSION
# define EL_CAN_PACKET_ENTRY_VERSION 1
#endif
# undef INTERFACE
# define INTERFACE ELCANPacketEntry
DECLARE_INTERFACE_(ELCANPacketEntry, ELItemInput) {
  STDMETHOD_(DWORD, InterfaceVersion)(THIS) PURE;
  STDMETHOD_(INPUTTYPE, Type)(THIS) PURE;
// Channel
//   Returns a channel number if input is self or an item.  Returns an index if an extern.
  STDMETHOD_(WORD, Channel)(THIS) PURE;
// Value
//   Only returns sane value if type is a constant.
  STDMETHOD_(float, Value)(THIS) PURE;
  STDMETHOD_(pELEndianess, Endianess)(THIS) PURE;
  STDMETHOD_(void, SetEndianess)(THIS_ pELEndianess endianess) PURE;
  STDMETHOD_(float, MinValue)(THIS) PURE;
  STDMETHOD_(void, SetMinValue)(THIS_ float value) PURE;
  STDMETHOD_(float, MaxValue)(THIS) PURE;
  STDMETHOD_(void, SetMaxValue)(THIS_ float value) PURE;
  STDMETHOD_(UINT, DataShift)(THIS) PURE;
  STDMETHOD_(void, SetDataShift)(THIS_ UINT shift) PURE;
  STDMETHOD_(UINT, DataBits)(THIS) PURE;
  STDMETHOD_(void, SetDataBits)(THIS_ UINT bits) PURE;
  STDMETHOD_(pELDataType, DataType)(THIS) PURE;
  STDMETHOD_(void, SetDataType)(THIS_ pELDataType type) PURE;
}; // ELCANPacketEntry
typedef ELCANPacketEntry *pELCANPacketEntry;

# ifndef EL_IGNORE_HELPER_MACROS
#  define ELCANPacketEntry_Endianess(p) FUNC(p)->Endianess(PARAM(p))
#  define ELCANPacketEntry_SetEndianess(p, a) FUNC(p)->SetEndianess(PARAM_(p) a)
#  define ELCANPacketEntry_MinValue(p) FUNC(p)->MinValue(PARAM(p))
#  define ELCANPacketEntry_SetMinValue(p, a) FUNC(p)->SetMinValue(PARAM_(p) a)
#  define ELCANPacketEntry_MaxValue(p) FUNC(p)->MaxValue(PARAM(p))
#  define ELCANPacketEntry_SetMaxValue(p, a) FUNC(p)->SetMaxValue(PARAM_(p) a)
#  define ELCANPacketEntry_DataShift(p) FUNC(p)->DataShift(PARAM(p))
#  define ELCANPacketEntry_SetDataShift(p, a) FUNC(p)->SetDataShift(PARAM_(p) a)
#  define ELCANPacketEntry_DataBits(p) FUNC(p)->DataBits(PARAM(p))
#  define ELCANPacketEntry_SetDataBits(p, a) FUNC(p)->SetDataBits(PARAM_(p) a)
#  define ELCANPacketEntry_DataType(p) FUNC(p)->DataType(PARAM(p))
#  define ELCANPacketEntry_SetDataType(p, a) FUNC(p)->SetDataType(PARAM_(p) a)
# endif

# undef INTERFACE
# define INTERFACE ELCANPacketEntries
DECLARE_INTERFACE_(ELCANPacketEntries, ELItemInputs) {
  STDMETHOD_(DWORD, InterfaceVersion)(THIS) PURE;
  STDMETHOD_(UINT, Count)(THIS) PURE;
  STDMETHOD_(pELItemInput, Input)(THIS_ UINT index) PURE;
  STDMETHOD_(void, Clear)(THIS) PURE;
// Add
//   Add for self, item, or extern.  channel is expected to be an index if adding an extern.
  STDMETHOD_(UINT, Add)(THIS_ INPUTTYPE type, UINT index, WORD channel) PURE;
  STDMETHOD_(UINT, AddConstant)(THIS_ UINT index, float value) PURE;
  STDMETHOD_(void, Remove)(THIS_ UINT index) PURE;
  STDMETHOD_(UINT, Swap)(THIS_ UINT first, UINT second) PURE;
}; // ELCANPacketEntries
typedef ELCANPacketEntries *pELCANPacketEntries;

#ifndef EL_CAN_PACKET_VERSION
# define EL_CAN_PACKET_VERSION 1
#endif
# undef INTERFACE
# define INTERFACE ELCANPacket
DECLARE_INTERFACE(ELCANPacket) {
  STDMETHOD_(DWORD, InterfaceVersion)(THIS) PURE;
  STDMETHOD_(DWORD, Address)(THIS) PURE;
  STDMETHOD_(void, SetAddress)(THIS_ DWORD address) PURE;
  STDMETHOD_(BOOL, Extended)(THIS) PURE;
  STDMETHOD_(void, SetExtended)(THIS_ BOOL value) PURE;
  STDMETHOD_(UINT, IterationCount)(THIS) PURE;
  STDMETHOD_(UINT, BitsAvailable)(THIS) PURE;
  STDMETHOD_(UINT, BitsUsed)(THIS) PURE;
  STDMETHOD_(pELCANPacketEntries, Entries)(THIS) PURE;
}; // ELCANPacket
typedef ELCANPacket *pELCANPacket;

# ifndef EL_IGNORE_HELPER_MACROS
#  define ELCANPacket_InterfaceVersion(p) FUNC(p)->InterfaceVersion(PARAM(p))
#  define ELCANPacket_Address(p) FUNC(p)->Address(PARAM(p))
#  define ELCANPacket_SetAddress(p, a) FUNC(p)->SetAddress(PARAM_(p) a)
#  define ELCANPacket_Extended(p) FUNC(p)->Extended(PARAM(p))
#  define ELCANPacket_SetExtended(p, a) FUNC(p)->SetExtended(PARAM_(p) a)
#  define ELCANPacket_IterationCount(p) FUNC(p)->IterationCount(PARAM(p))
#  define ELCANPacket_BitsAvailable(p) FUNC(p)->BitsAvailable(PARAM(p))
#  define ELCANPacket_BitsUsed(p) FUNC(p)->BitsUsed(PARAM(p))
#  define ELCANPacket_Entries(p) FUNC(p)->Entries(PARAM(p))
# endif

#ifndef EL_CANPACKET_ITEM_VERSION
# define EL_CANPACKET_ITEM_VERSION 1
#endif
# undef INTERFACE
# define INTERFACE ELCANPacketItem
DECLARE_INTERFACE_(ELCANPacketItem, ELItem) {
  STDMETHOD_(DWORD, InterfaceVersion)(THIS) PURE;
  STDMETHOD_(void, Release)(THIS) PURE;
  STDMETHOD_(pELItemType, Type)(THIS) PURE;
  STDMETHOD_(WORD, Channel)(THIS) PURE;
  STDMETHOD_(const char *, Name)(THIS) PURE;
  STDMETHOD_(pELItemHeader, Header)(THIS) PURE;
// MaxPacketSize
//   Size returned shall be in bytes.
  STDMETHOD_(UINT, MaxPacketSize)(THIS) PURE;
  STDMETHOD_(UINT, NumberOfEntries)(THIS) PURE;
  STDMETHOD_(void, SetNumberOfEntries)(THIS_ UINT count) PURE;
  STDMETHOD_(pELBusOverride, ChannelBusOverride)(THIS) PURE;
  STDMETHOD_(pELLatch, EventLatch)(THIS) PURE;
}; // ELCANPacketItem
typedef ELCANPacketItem *pELCANPacketItem;

# ifndef EL_IGNORE_HELPER_MACROS
#  define ELCANPacketItem_MaxPacketSize(p) FUNC(p)->MaxPacketSize(PARAM(p))
#  define ELCANPacketItem_NumberOfEntries(p) FUNC(p)->NumberOfEntries(PARAM(p))
#  define ELCANPacketItem_SetNumberOfEntries(p, a) FUNC(p)->SetNumberOfEntries(PARAM_(p) a)
#  define ELCANPacketItem_ChannelBusOverride(p) FUNC(p)->ChannelBusOverride(PARAM(p))
#  define ELCANPacketItem_EventLatch(p) FUNC(p)->EventLatch(PARAM(p))
# endif

// Undefine document specific stuff.
# undef FUNC
# undef PARAM
# undef PARAM_

// Functions required
#ifndef EL_DLL_EXPORT
# define EL_DLL_EXPORT _declspec(dllexport)
#endif

#if defined(__cplusplus)
extern "C" {
#endif
  EL_DLL_EXPORT const pELVersions InitializeDockablePlugIn(const pELVersions versions, pELHost host, const pELGenericFunctionTable generic_functions);
  EL_DLL_EXPORT void InitializeDockablePlugInFinished(PLUGINSTATUS status, UINT * plugin_ids, UINT * menu_ids, UINT id_count);
  EL_DLL_EXPORT void GetPlugInMenuString(char ** menu_string, UINT * length);
  EL_DLL_EXPORT void MenuClicked(WORD menu_id);
  EL_DLL_EXPORT void GetPlugInName(char ** plugin_name, UINT * length);
  EL_DLL_EXPORT void TargetConnected(pELTarget target);
  EL_DLL_EXPORT void TargetDisconnected(pELTarget target);
  EL_DLL_EXPORT void HostReady(pELHost host, pELLayout layout);
# if EL_UPGRADE_HOOK_SUPPORT
  EL_DLL_EXPORT int UpgradeHook(int status, void * context);
# endif // EL_UPGRADE_HOOK_SUPPORT
# if EL_SUPPORTED_CONTROLS_SUPPORT
  EL_DLL_EXPORT pELControlInfo SupportedControls();
# endif // EL_SUPPORTED_CONTROLS_SUPPORT
# if EL_SAVABLE_WINDOWS_SUPPORT
  EL_DLL_EXPORT pELWindowInfo SavableWindows();
# endif // EL_SAVABLE_WINDOWS_SUPPORT
# if EL_LAYOUT_CONTROLS_SUPPORT
  EL_DLL_EXPORT pELLayoutInfo LayoutControls();
# endif // EL_LAYOUT_CONTROLS_SUPPORT
#if defined(__cplusplus)
}
#endif

#endif
